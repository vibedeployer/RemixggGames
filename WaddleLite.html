<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Penguro Roguelite</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.js"></script>
    <style>
      @font-face {
        font-family: "Fobble";
        src: url("https://artificialisle.github.io/font/Fobble_regular-Regular%20(1)%20(1).otf")
          format("opentype");
      }
    </style>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #1a1a2e;
        font-family: "Arial", sans-serif;
      }
      #game-container {
        position: relative;
        aspect-ratio: 2 / 3;
        max-width: 500px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@0.2.1/dist/index.min.js"></script>
  </head>
  <body>
    <div id="game-container"></div>

    <script>
      // Farcade SDK instance
      const sdk = window.FarcadeSDK;

      // Game data management using Farcade SDK
      class GameData {
        constructor() {
          this.embers = 0;
          this.totalRuns = 0;
          this.bestWave = 0;
          this.upgrades = {
            // Fire Path
            emberEfficiency: 0,
            burningBullets: 0,
            fireTotem: 0,
            phoenixRebirth: 0,
            // Ice Path
            coldResistance: 0,
            iceArmor: 0,
            frostBullets: 0,
            blizzard: 0,
            // Penguin Path
            waddleMastery: 0,
            bellySlide: 0,
            fishFeast: 0,
            packLeader: 0,
          };
          this.playerName = "Penguin";
          this.playerImage = "";
          this.isMuted = false;
          this.initialized = false;
        }

        async initialize(initialGameState) {
          if (initialGameState) {
            this.embers = initialGameState.embers || 0;
            this.totalRuns = initialGameState.totalRuns || 0;
            this.bestWave = initialGameState.bestWave || 0;
            this.upgrades = initialGameState.upgrades || {
              // Fire Path
              emberEfficiency: 0,
              burningBullets: 0,
              fireTotem: 0,
              phoenixRebirth: 0,
              // Ice Path
              coldResistance: 0,
              iceArmor: 0,
              frostBullets: 0,
              blizzard: 0,
              // Penguin Path
              waddleMastery: 0,
              bellySlide: 0,
              fishFeast: 0,
              packLeader: 0,
            };
          }
          this.initialized = true;
          console.log("GameData initialized:", this);
        }

        getGameState() {
          return {
            embers: this.embers,
            totalRuns: this.totalRuns,
            bestWave: this.bestWave,
            upgrades: this.upgrades,
          };
        }

        saveGameState() {
          if (this.initialized && sdk && sdk.singlePlayer) {
            try {
              sdk.singlePlayer.actions.saveGameState({
                gameState: this.getGameState(),
              });
              console.log("Game state saved:", this.getGameState());
            } catch (error) {
              console.error("Error saving game state:", error);
            }
          }
        }
      }

      // Global game data instance
      const gameData = new GameData();

      // For backward compatibility with existing code
      const GameRegistry = gameData;

      class BootLoader extends Phaser.Scene {
        constructor() {
          super({ key: "BootLoader" });
        }

        preload() {
          this.loadFontPromise = document.fonts.load('16px "Fobble"');
          this.loadFontPromise = document.fonts.load('16px "Menco"');
          // Create loading bar
          this.createLoadingBar();

          // Load all essential assets

          this.load.image(
            "igloo_bg",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Generated_Image_1h62jp1h62jp1h62-pBR9sge9TDIheJigMeUhGmCj9qWf6W.png?7u6Z"
          );
          this.load.image(
            "igloo_bgfiretop",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Generated_Image_1h62jp1h62jp1h62-12o630yO2Dw4qrFgaz3V1uSbr8kXdI.png?VyfJ"
          );
          this.load.image(
            "sky",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Generated_Image_6kdqsu6kdqsu6kdq-fHT3Fpb45N36sd3Nw7AuBN9QbIxapk.png?Qwhk"
          );

          this.load.spritesheet(
            "pudgyPenguin",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/9375757a-c977-4071-afba-9a1bf45d098d/All%20Characters-Character02-Walk_00-sheet-2gBZY6agvwcxyVW3JSV9Pee7RuOpkh.png?sWve",
            { frameWidth: 96, frameHeight: 128 }
          );

          this.load.spritesheet(
            "snowball",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/snowball_01-sheet-xPmtmIy26NmR62vmzlhVPZwr5qADvT.png?CKzq",
            { frameWidth: 256, frameHeight: 193 }
          );

          this.load.spritesheet(
            "pudgyPenguinIdle",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/d677a658-52fc-490b-8e25-a8e8e6049a7e/All%20Characters-Character02-Idle_00-sheet-04NSwTEtxlAL0zXCZFoVV6vyoPqVjW.png?axGy",
            { frameWidth: 96, frameHeight: 128 }
          );

          this.load.spritesheet(
            "pudgyPenguinNPC",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/All%20Characters-Character09-Idle_00-sheet-wMxNAaxxuHTVcPYFHqMbw8dwwhNYb9.png?GlYn",
            { frameWidth: 200, frameHeight: 230 }
          );

          this.load.spritesheet(
            "enemy1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Walk_00-sheet-HKFGXGdO1zN4DvDQKcUcjIvnjrmO2F.png?iFS5",
            { frameWidth: 96, frameHeight: 96 }
          );
          this.load.spritesheet(
            "enemy2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/skeleton-Idle_0-sheet-xAL765Ks8ZH39kIfuziKy7jUlYRpsR.png?xTb2",
            { frameWidth: 92, frameHeight: 131 }
          );
          this.load.spritesheet(
            "enemy3",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Walk_00-sheet-rc1uztPjfmOB1W1SYzqW0DHQFp1fLY.png?sl95",
            { frameWidth: 138, frameHeight: 100 }
          );
          this.load.spritesheet(
            "enemy4",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/MoveAndIdle_00-sheet-TzxsEHqscRmRagmYvOzT1uk27c8Fgo.png?EJg4",
            { frameWidth: 105, frameHeight: 105 }
          );
          this.load.spritesheet(
            "enemy5",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/skeleton-Walk_0-sheet-p2JW3JAgAkYY1r86p3MO1UhUl2lWHD.png?xQpy",
            { frameWidth: 189, frameHeight: 158 }
          );

          this.load.spritesheet(
            "explosion1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Effect-fx01_0-sheet-ZiuMAs5jy84MW8BdvDa8pTGU4XVfwQ.png?YvTh",
            { frameWidth: 186, frameHeight: 158 }
          );
          this.load.spritesheet(
            "explosion2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/00-sheet-PsqAjfDwkh7xNPyQoHnqJ0mU1WMt2o.png?FsVd",
            { frameWidth: 200, frameHeight: 200 }
          );

          this.load.spritesheet(
            "shopFire",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/1-sheet-RMOdxFsJwitjEMP7vEpllfzzHMxDUC.png?LFv6",
            { frameWidth: 300, frameHeight: 300 }
          );
          this.load.spritesheet(
            "shopFire2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/1-sheet-Pf50Qu89DmxEetdibT6DkUlFw7uvhZ.png?kLOr",
            { frameWidth: 250, frameHeight: 300 }
          );

          this.load.spritesheet(
            "tapcursor",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Animated%20Tutorial%20Cursor-Tap_00-sheet-GVhLRjCimAkZnpHrsPzOZhNnfJMBKn.png?AdIZ",
            { frameWidth: 300, frameHeight: 300 }
          );

          this.load.image(
            "backpack",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Generated_Image_6c4ej96c4ej96c4e-tvTvxIRxj19mrM9jjxuE1W4gCHsFYf.png?l7YZ"
          );

          this.load.image(
            "backpack2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Generated_Image_6c4ej96c4ej96c4e%20copy-3Y61IxbXgjn8cGKx86qfPbyYEmmldE.png?WAU2"
          );

          this.load.image(
            "gamebg",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/untitled-SAPauRWNbdm4XJsECxwofl3znGt2hr.png?EnOJ"
          );
          this.load.image(
            "gamebg2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/Gemini_Gene-CmOtRWc4tpgJb07C2THp9JTXbrGyDO.png?BiGX"
          );

          this.load.image(
            "fow",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/cec49d06-d4f3-41ea-90fc-fe0a5220600e/fowfixed-JI2DInYTvPixjZxn0piXhFRpJdZddx.png?M3cZ"
          );

          this.load.audio(
            "npctalking1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/1-CVzztsyaPpatwfitJn3WOC6gkFsWLG.mp3?zQ4i"
          );
          this.load.audio(
            "npctalking2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/2-ywC9lGpCWvYZaPMnPzJx1yA3OkQI24.mp3?lK53"
          );
          this.load.audio(
            "npctalking3",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/3-JjfibJxv4bQP8punivXKsePcLYVSGA.mp3?477z"
          );
          this.load.audio(
            "npctalking4",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/4-FcnJUzXcr9AW0aCEpLNDpSpLmvUH7d.mp3?Uxco"
          );
          this.load.audio(
            "npctalking5",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/5-iwPmSJotbahBAj5pkSA6IqbKptKIu1.mp3?Co8D"
          );
          this.load.audio(
            "npctalking6",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/6-87g4YfNDrXnHcOpMuKSsSXpu51wSPi.mp3?6exY"
          );

          this.load.audio(
            "HubMusic",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/pole-288242-Fjd6vWm5I63S87gct4YY1ior2l6XQw.mp3?oo2w"
          );

          this.load.audio(
            "FightMusic",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/battle-fighting-warrior-drums-372078-tolvGuAUTAdPOOdWjPqnI9CzD3qggI.mp3?Soje"
          );
          this.load.audio(
            "LevelUpMusic",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/taiko-percussion-loop-preparation-for-action-355034-HbKoMGJX9MmQFTjPMIBvE9LlKb7okM.mp3?E8wC"
          );

          this.load.audio(
            "AmbienceFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cold-wind-ambience-404245-kksnwL1SwDBhmKk5dlNlLHfwHdIlka.mp3?GlWk"
          );
          this.load.audio(
            "FireSpellFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/flame-spell-impact-393919-Qg0rBllV0PrqgOEffUGqgPN350jDdp.mp3?Q8jj"
          );
          this.load.audio(
            "WhooshFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/heavy-whoosh-05-414582-ykWh0bmTZJ5jWENSMqLKIoanDRKOZf.mp3?n3CB"
          );
          this.load.audio(
            "FireCracklingFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/fire-sound-310285-reo6AtFnJZlFRg8xYjxzb60jZ1QmGE.mp3?ChCx"
          );

          this.load.audio(
            "LevelUpFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c7d533fd-3fb1-4432-98dc-8d42fe102ae0/bonus-points-190035-79k9rRh8tAOdydGaqwZpqzvcXvJTzG.mp3?x82x"
          );
          this.load.audio(
            "DropEmberFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/attack-fire-2-384916-L6IszGaPqLfaixmUiLDx1V3qYO3dwZ.mp3?Btel"
          );

          this.load.audio(
            "NotifyFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/system-notification-199277-51sLj7xndeNbTwtlL6BjmB74V14SZ8.mp3?oX98"
          );

          this.load.audio(
            "ClickFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/9375757a-c977-4071-afba-9a1bf45d098d/minimal-pop-click-ui-1-198301-UDXG34BcgCKKjEUHcx0hQqyHaSoUws.mp3?0BoM"
          );

          this.load.audio(
            "HitFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/9375757a-c977-4071-afba-9a1bf45d098d/hit-zjSAbNHwMeQd6uSXHJMtVEKeBVONgX.mp3?0JMD"
          );
          this.load.audio(
            "ShootFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_penguin_snow-1760606268188-V4pJEQwRJEGQQN0z3JsGYm3jx007qA.mp3?5UPb"
          );
          this.load.audio(
            "DeathFx1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_enemy_death-1760606558550-Ha51sf54ocuRGyvPSVvgMPEMMw436k.mp3?GSKH"
          );
          this.load.audio(
            "DeathFx2",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_enemy_death-1760606581687-U8DbRAeg1esVKgmHfBQAC4jnQRkgMD.mp3?mu97"
          );
          this.load.audio(
            "DeathFx3",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_e-uYWgjnm9Vk3dLwivYxuurFSGRDoYaf.mp3?1OrQ"
          );
          this.load.audio(
            "DeathFx4",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cart-9YzECxbmCBI98gxr9xqpskxnMqORK8.mp3?Bkxe"
          );
          this.load.audio(
            "DeathFx5",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_enemy_short-TMzw1jOjsMBX6pi8r3CKMU4tRsNtpE.mp3?YrzT"
          );

          this.load.audio(
            "EnemyExplosionFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/6ab0b863-f79b-469e-8faa-2b6ea3adf429/cartoon_ex-nuOWOt3OessokPJirjQ78e84DwU0C7.mp3?dikx"
          );

          this.load.audio(
            "CollectPointsFx",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c7d533fd-3fb1-4432-98dc-8d42fe102ae0/collect-points-190037-8MzjprIUq3e6c9znu5f7ex8FmrjfHB.mp3?HLn0"
          );

          // Load progress events
          this.load.on("progress", this.updateLoadingBar, this);
          this.load.on("complete", this.onLoadComplete, this);
        }

        createLoadingBar() {
          this.cameras.main.fadeIn(500, 0, 0, 0);
          this.cameras.main.setBackgroundColor(0x00142d);

          // Loading text
          this.loadingText = this.add
            .text(200, 280, "Loading...", {
              fontFamily: "Fobble",
              fontSize: "48px",
              fill: "#ffffff",
              stroke: "#000000",
              strokeThickness: 0,
              align: "center",
            })
            .setOrigin(0.5);

          // Graphics for background
          this.loadingBarBg = this.add.graphics();
          this.loadingBarBg.fillStyle(0x000000, 0.3);
          this.loadingBarBg.fillRoundedRect(50, 310, 300, 20, 10);

          // Graphics for fill
          this.loadingBarFill = this.add.graphics();
          this.loadingBarFill.fillStyle(0xa9ff99, 1);
          this.loadingBarFill.fillRoundedRect(50, 310, 0, 20, 10);

          this.loadingBarWidth = 300;
        }

        updateLoadingBar(progress) {
          // Update loading bar
          this.loadingBarFill.clear();
          this.loadingBarFill.fillStyle(0xa9ff99, 1);
          this.loadingBarFill.fillRoundedRect(
            50,
            310,
            this.loadingBarWidth * progress,
            20,
            10
          );
          // Update loading text
          const percentage = Math.round(progress * 100);
          this.loadingText.setText(`Loading... ${percentage}%`);
        }

        onLoadComplete() {
          // Small delay before transitioning
          this.time.delayedCall(1000, () => {
            this.cameras.main.fadeOut(500);
            this.scene.start("IglooHubScene");
          });
        }
      }

      // ===== IGLOO HUB SCENE =====
      class IglooHubScene extends Phaser.Scene {
        constructor() {
          super({ key: "IglooHubScene" });
        }

        preload() {
          this.loadFontPromise = document.fonts.load('16px "Fobble"');
          // Load igloo background image
        }

        async create() {
          // Initialize game data if not already done
          if (!gameData.initialized) {
            await gameData.initialize();
          }

          // Create animations
          this.anims.create({
            key: "walk",
            frames: this.anims.generateFrameNumbers("pudgyPenguin", {
              start: 0,
              end: 30,
            }),
            frameRate: 30,
            repeat: -1,
          });

          this.anims.create({
            key: "idle",
            frames: this.anims.generateFrameNumbers("pudgyPenguinIdle", {
              start: 0,
              end: 19,
            }),
            frameRate: 19,
            repeat: -1,
          });

          this.anims.create({
            key: "snowballMovement",
            frames: this.anims.generateFrameNumbers("snowball", {
              start: 0,
              end: 5,
            }),
            frameRate: 8,
            repeat: -1, // Loop infinitely
          });

          this.anims.create({
            key: "npcidle",
            frames: this.anims.generateFrameNumbers("pudgyPenguinNPC", {
              start: 0,
              end: 19,
            }),
            frameRate: 19,
            repeat: -1,
          });

          // Shop fire animation (loops)
          this.anims.create({
            key: "fireIgnite",
            frames: this.anims.generateFrameNumbers("shopFire", {
              start: 0,
              end: 7,
            }),
            frameRate: 8,
            repeat: -1, // Loop infinitely
          });
          this.anims.create({
            key: "fireIgnite2",
            frames: this.anims.generateFrameNumbers("shopFire2", {
              start: 0,
              end: 6,
            }),
            frameRate: 6,
            repeat: -1, // Loop infinitely
          });

          // Enemy animations
          this.anims.create({
            key: "enemy1Walk",
            frames: this.anims.generateFrameNumbers("enemy1", {
              start: 0,
              end: 19,
            }),
            frameRate: 12,
            repeat: -1,
          });

          this.anims.create({
            key: "enemy2Walk",
            frames: this.anims.generateFrameNumbers("enemy2", {
              start: 0,
              end: 16,
            }),
            frameRate: 8,
            repeat: -1,
          });

          this.anims.create({
            key: "enemy3Walk",
            frames: this.anims.generateFrameNumbers("enemy3", {
              start: 0,
              end: 19,
            }),
            frameRate: 12,
            repeat: -1,
          });

          this.anims.create({
            key: "enemy4Walk",
            frames: this.anims.generateFrameNumbers("enemy4", {
              start: 0,
              end: 19,
            }),
            frameRate: 12,
            repeat: -1,
          });

          this.anims.create({
            key: "enemy5Walk",
            frames: this.anims.generateFrameNumbers("enemy5", {
              start: 0,
              end: 17,
            }),
            frameRate: 12,
            repeat: -1,
          });

          // Tap cursor animation (10 frames)
          this.anims.create({
            key: "tapcursorAnim",
            frames: this.anims.generateFrameNumbers("tapcursor", {
              start: 0,
              end: 9,
            }),
            frameRate: 16,
            repeat: -1,
          });

          // Tap cursor hold animation (frames 0-7, hold on 7)
          this.anims.create({
            key: "tapcursorHold",
            frames: this.anims.generateFrameNumbers("tapcursor", {
              start: 0,
              end: 7,
            }),
            frameRate: 16,
            repeat: 0, // Don't repeat, hold on last frame
          });

          // Explosion animation (18 frames)
          this.anims.create({
            key: "enemyExplosion",
            frames: this.anims.generateFrameNumbers("explosion1", {
              start: 0,
              end: 17,
            }),
            frameRate: 24,
            repeat: 0,
            hideOnComplete: true,
          });

          this.anims.create({
            key: "enemyExplosion2",
            frames: this.anims.generateFrameNumbers("explosion2", {
              start: 0,
              end: 15,
            }),
            frameRate: 24,
            repeat: 0,
            hideOnComplete: true,
          });

          // Player state
          this.player = null;
          this.cursors = null;
          this.wasd = {};
          this.nearShop = false;
          this.nearDoor = false;
          this.shopOpen = false;
          this.cinematicPlaying = false;
          this.dialogueBox = null;

          // Floating text for interactive zones
          this.shopFloatingText = null;
          this.doorFloatingText = null;
          this.shopFloatingTextFading = false;
          this.doorFloatingTextFading = false;
          this.npcDialogueActive = false;
          this.lastNPCClickTime = 0;
          this.dialogueClosing = false;

          // Backpack UI properties
          this.backpackSprite = null;
          this.backpackSprite2 = null;
          this.backpackEmberText = null;
          this.backpackFire = null;
          this.backpackFire2 = null;

          // Create wider world for belt-scroller effect (image is wider than screen)
          const worldWidth = 1200;
          const worldHeight = 600;

          this.physics.world.setBounds(0, 0, worldWidth, worldHeight);
          this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
          // Parallax sky background
          const bgparralax = this.add.image(180, 175, "sky");
          bgparralax.setOrigin(0, 0);
          bgparralax.setScrollFactor(0.5); // Slower parallax for depth
          bgparralax.setScale(0.3); // Scale up to cover more area
          bgparralax.setDepth(-10); // Set depth to 100

          // Create snow texture (white circle)
          const snowTexture = this.add.graphics();
          snowTexture.fillStyle(0xffffff);
          snowTexture.fillCircle(4, 4, 4);
          snowTexture.generateTexture("snowCircle", 8, 8);

          // Snow particles (far layer - behind igloo)
          const snowFar = this.add.particles(0, 0, "snowCircle", {
            x: { min: 0, max: worldWidth },
            y: -20,
            lifespan: 8000,
            speedY: { min: 30, max: 60 },
            speedX: { min: -20, max: 20 },
            scale: { start: 0.5, end: 0.2 },
            alpha: { start: 0.6, end: 0.1 },
            frequency: 100,
            blendMode: "ADD",
          });
          snowFar.setScrollFactor(0.4);
          snowFar.setDepth(-8); // Set depth to 100

          // Snow particles (mid layer - drifting)
          const snowMid = this.add.particles(0, 0, "snowCircle", {
            x: { min: 0, max: worldWidth },
            y: -20,
            lifespan: 6000,
            speedY: { min: 50, max: 80 },
            speedX: { min: -30, max: 30 },
            scale: { start: 0.7, end: 0.3 },
            alpha: { start: 0.8, end: 0.3 },
            frequency: 80,
            blendMode: "ADD",
          });
          snowMid.setScrollFactor(0.6);
          snowMid.setDepth(-6); // Set depth to 100

          // Add the igloo background image
          const bg = this.add.image(0, 0, "igloo_bg");
          bg.setOrigin(0, 0);
          bg.setDepth(-1);

          // Scale image to fit height and maintain aspect ratio
          const scale = worldHeight / bg.height;
          bg.setScale(scale);

          // If image is not wide enough, tile or stretch it
          if (bg.displayWidth < worldWidth) {
            bg.setDisplaySize(worldWidth, worldHeight);
          }

          // Add the igloo background image
          const bg2 = this.add.image(0, 0, "igloo_bgfiretop");
          bg2.setOrigin(0, 0);
          bg2.setDepth(0);

          // Scale image to fit height and maintain aspect ratio
          const scale2 = worldHeight / bg.height;
          bg2.setScale(scale);

          // If image is not wide enough, tile or stretch it
          if (bg2.displayWidth < worldWidth) {
            bg2.setDisplaySize(worldWidth, worldHeight);
          }

          // Archway position (for door placement) - estimate from image
          const archX = 600;
          this.archX = archX; // Store for cinematic use

          // Invisible ground/floor for physics
          const floor = this.add.rectangle(
            worldWidth / 2,
            560,
            worldWidth,
            80,
            0x000000,
            0
          );
          this.physics.add.existing(floor, true);

          // Snow particles (foreground layer - closest, in front of igloo)
          const snowNear = this.add.particles(0, 0, "snowCircle", {
            x: { min: 0, max: worldWidth },
            y: -20,
            lifespan: 5000,
            speedY: { min: 80, max: 120 },
            speedX: { min: -40, max: 40 },
            scale: { start: 0.12, end: 0.08 },
            alpha: { start: 0.9, end: 0.5 },
            frequency: 60,
            blendMode: "ADD",
          });
          snowNear.setDepth(-4); // Above igloo and player
          snowNear.setScrollFactor(1); // Moves with camera

          // UI - Fixed to camera (scrollFactor 0)
          /*  this.titleText = this.add
            .text(200, 30, "🏠 PENGUIN IGLOO", {
              fontFamily: "Fobble",
              fontSize: "28px",
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 4,
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(200)
            .setVisible(true);  */

          this.statsText = this.add
            .text(
              200,
              90,
              `Runs: ${GameRegistry.totalRuns} | Best: ${GameRegistry.bestWave}`,
              {
                fontSize: "32px",
                fontFamily: "Fobble",
                color: "#ffffff",
                stroke: "#000000",
                strokeThickness: 2,
              }
            )
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(200)
            .setVisible(false); // Always visible now, will hide during cinematic if needed

          // Create backpack UI
          this.createBackpackUI();

          // Player - animated penguin sprite (start position will be set based on cinematic)
          const startX = 900; // Default position

          this.player = this.add.sprite(startX, 450, "pudgyPenguin");
          this.player.setScale(1.3);
          this.physics.add.existing(this.player);
          this.player.body.setCollideWorldBounds(true);
          this.player.body.setSize(60, 80);
          this.player.setDepth(1);
          this.player.play("idle");

          // NPC Elder Penguin (wise guide) - permanent resident
          this.npc = this.add.sprite(worldWidth - 150, 440, "pudgyPenguinNPC");
          this.npc.setScale(0.6);
          // this.npc.setTint(0x88ccff); // Light blue tint to differentiate
          this.npc.setFlipX(true); // Face left toward the igloo
          this.npc.setAlpha(0.8); // Slightly transparent when not interacting
          this.npc.anims.play("npcidle");
          this.nearNPC = false;

          // Camera follows player horizontally (will be set up after checking for cinematic)
          this.cameras.main.startFollow(this.player, false, 0.1, 0);
          this.cameras.main.setDeadzone(150, worldHeight);

          // Input
          this.cursors = this.input.keyboard.createCursorKeys();
          this.wasd = {
            W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
            A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
            D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
          };

          // Create mobile joystick (only if not in cinematic)
          if (!this.cinematicPlaying) {
            this.createMobileJoystick();
          }

          // Start ambient sound loop
          this.ambientSound = this.sound.add("AmbienceFx", {
            loop: true,
            volume: 0.3,
          });
          this.ambientSound.play();

          this.HubMusic = this.sound.add("HubMusic", {
            loop: true,
            volume: 0.7,
          });
          this.HubMusic.play();

          // Shop zone (left side) - invisible, just for collision detection
          this.shopZone = this.add.circle(330, 510, 70, 0xffe092, 0);
          this.shopZone.setDepth(1);
          this.shopZone.setVisible(false); // invisible

          this.physics.add.existing(this.shopZone, true);

          // Shop fire sprite
          this.shopFire = this.add.sprite(255, 320, "shopFire");
          this.shopFire.setScale(1);
          this.shopFire.setVisible(false); // Hidden initially
          this.shopFire.setDepth(-1);
          this.shopFire.setAlpha(0.95);

          this.shopFire2 = this.add.sprite(252, 350, "shopFire2");
          this.shopFire2.setScale(0.8);
          this.shopFire2.setVisible(false); // Hidden initially
          this.shopFire2.setDepth(-1);
          this.shopFire2.setAlpha(0.9);

          // Multi-layer shop glow effect for rich animation
          // Outer glow - starts small, grows when near
          this.shopGlowOuter = this.add.circle(330, 510, 45, 0xff8c00, 0.15);
          this.shopGlowOuter.setDepth(0);
          this.shopGlowOuter.setScale(0.5); // Start smaller
          this.shopGlowOuter.setVisible(false);

          // Middle glow - starts small, grows when near
          this.shopGlowMiddle = this.add.circle(330, 510, 35, 0xffe092, 0.25);
          this.shopGlowMiddle.setDepth(1);
          this.shopGlowMiddle.setScale(0.5); // Start smaller
          this.shopGlowMiddle.setVisible(false);

          // Inner glow - starts small, grows when near
          this.shopGlowInner = this.add.circle(330, 510, 25, 0xffcc00, 0.4);
          this.shopGlowInner.setDepth(1);
          this.shopGlowInner.setScale(0.5); // Start smaller
          this.shopGlowInner.setVisible(false);

          // Store main glow reference (for cinematic control)
          this.shopGlow = this.shopGlowMiddle;

          // Default setup for returning players (will be overridden if cinematic plays)
          this.shopFire.setVisible(true);
          this.shopFire.play("fireIgnite"); // Play looping fire animation
          this.shopFire2.setVisible(true);
          this.shopFire2.play("fireIgnite2");

          // Animate outer glow - slow, subtle breathing (smaller base)
          this.tweens.add({
            targets: this.shopGlowOuter,
            scale: 0.7,
            alpha: 0.25,
            duration: 2000,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Animate middle glow - medium pace (smaller base)
          this.tweens.add({
            targets: this.shopGlowMiddle,
            scale: 0.65,
            alpha: 0.4,
            duration: 1200,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Animate inner glow - fast, pulsing (smaller base)
          this.tweens.add({
            targets: this.shopGlowInner,
            scale: 0.6,
            alpha: 0.6,
            duration: 800,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Exit Door (at the archway) - invisible zone for collision detection
          this.doorZone = this.add.rectangle(archX, 510, 140, 100, 0x8b4513, 0);
          this.physics.add.existing(this.doorZone, true);

          // Multi-layer door glow effect (blue theme)
          // Outer glow - starts small, grows when near
          this.doorGlowOuter = this.add.circle(archX, 510, 45, 0x0088ff, 0.15);
          this.doorGlowOuter.setDepth(0);
          this.doorGlowOuter.setScale(0.5); // Start smaller
          this.doorGlowOuter.setVisible(false);

          // Middle glow - starts small, grows when near
          this.doorGlowMiddle = this.add.circle(archX, 510, 35, 0x80abff, 0.25);
          this.doorGlowMiddle.setDepth(1);
          this.doorGlowMiddle.setScale(0.5); // Start smaller
          this.doorGlowMiddle.setVisible(false);

          // Inner glow - starts small, grows when near
          this.doorGlowInner = this.add.circle(archX, 510, 25, 0x00ddff, 0.4);
          this.doorGlowInner.setDepth(1);
          this.doorGlowInner.setScale(0.5); // Start smaller
          this.doorGlowInner.setVisible(false);

          // Store main glow reference (for compatibility)
          this.doorGlow = this.doorGlowMiddle;

          // Animate outer glow - slow, subtle breathing (smaller base)
          this.tweens.add({
            targets: this.doorGlowOuter,
            scale: 0.7,
            alpha: 0.25,
            duration: 2000,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Animate middle glow - medium pace (smaller base)
          this.tweens.add({
            targets: this.doorGlowMiddle,
            scale: 0.65,
            alpha: 0.4,
            duration: 1200,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Animate inner glow - fast, pulsing (smaller base)
          this.tweens.add({
            targets: this.doorGlowInner,
            scale: 0.6,
            alpha: 0.6,
            duration: 800,
            yoyo: true,
            repeat: -1,
            ease: "Sine.easeInOut",
          });

          // Click to interact
          this.input.on("pointerdown", (pointer) => {
            if (
              this.dialogueBox &&
              this.dialogueBox.continue.visible &&
              !this.dialogueClosing
            ) {
              this.sound.play("ClickFx", { volume: 0.5 });
              this.dialogueClosing = true; // Prevent multiple continue actions

              // Clean up typewriter event
              if (this.dialogueBox.typewriterEvent) {
                this.dialogueBox.typewriterEvent.remove();
              }

              // Stop any existing tweens on dialogue elements
              this.tweens.killTweensOf([
                this.dialogueBox.bg,
                this.dialogueBox.text,
                this.dialogueBox.continue,
              ]);

              // Click to continue dialogue - fade out and destroy
              this.tweens.add({
                targets: [
                  this.dialogueBox.bg,
                  this.dialogueBox.text,
                  this.dialogueBox.continue,
                ],
                alpha: 0,
                duration: 200,
                ease: "Power2.easeOut",
                onComplete: () => {
                  if (this.dialogueBox) {
                    // Stop NPC sound if it exists
                    if (this.currentNPCSound && this.currentNPCSound.stop) {
                      this.currentNPCSound.stop();
                      this.currentNPCSound = null;
                    }
                    // Clean up typewriter event if it exists
                    if (this.dialogueBox.typewriterEvent) {
                      this.dialogueBox.typewriterEvent.remove();
                    }
                    this.dialogueBox.bg.destroy();
                    this.dialogueBox.text.destroy();
                    this.dialogueBox.continue.destroy();
                    this.dialogueBox = null;
                  }
                  this.npcDialogueActive = false;
                  this.dialogueClosing = false; // Reset flag
                },
              });
            } else if (
              this.nearNPC &&
              !this.shopOpen &&
              !this.cinematicPlaying &&
              !this.npcDialogueActive &&
              this.time.now - this.lastNPCClickTime > 500
            ) {
              // Allow NPC interactions anywhere on screen (including joystick area)
              this.sound.play("ClickFx", { volume: 0.5 });
              this.lastNPCClickTime = this.time.now;
              this.showNPCHint();
            } else if (pointer.y <= 400) {
              // Only allow shop and door interactions above y=400 to avoid joystick area
              if (this.nearShop && !this.shopOpen) {
                this.sound.play("ClickFx", { volume: 0.5 });
                this.openShop();
              } else if (this.nearDoor && !this.shopOpen) {
                this.sound.play("ClickFx", { volume: 0.5 });

                // Start cinematic transition to game
                this.startGameTransition();
              }
            }
          });

          // Shop UI container (hidden initially, fixed to camera)
          this.shopContainer = this.add
            .container(0, 0)
            .setVisible(false)
            .setScrollFactor(0)
            .setDepth(300); // Above snow and UI

          // Check if first time (game state already loaded by SDK before scene creation)
          const isFirstTime = GameRegistry.totalRuns === 0;

          console.log(
            "IglooHubScene - isFirstTime:",
            isFirstTime,
            "totalRuns:",
            GameRegistry.totalRuns
          );

          // Start fire crackling sound for returning players (not first time)
          if (!isFirstTime) {
            this.fireCracklingSound = this.sound.add("FireCracklingFx", {
              loop: true,
              volume: 0.45,
            });
            this.fireCracklingSound.play();
          }

          // Update UI with loaded values
          this.statsText.setText(
            `Runs: ${GameRegistry.totalRuns} | Best: ${GameRegistry.bestWave}`
          );

          if (isFirstTime) {
            // Setup for cinematic
            this.player.x = 900; // Move player near NPC
            // this.titleText.setVisible(false);
            this.statsText.setVisible(false);

            // Hide fire and stop all glow layers for dramatic ignition
            this.shopFire.setVisible(false);
            this.shopFire2.setVisible(false);
            this.backpackSprite.setVisible(false);
            this.backpackSprite2.setVisible(false);
            this.backpackEmberText.setVisible(false);
            if (this.backpackParticles)
              this.backpackParticles.setVisible(false);
            if (this.backpackYellowParticles)
              this.backpackYellowParticles.setVisible(false);
            this.shopGlowOuter.setAlpha(0);
            this.shopGlowMiddle.setAlpha(0);
            this.shopGlowInner.setAlpha(0);
            this.tweens.killTweensOf([
              this.shopGlowOuter,
              this.shopGlowMiddle,
              this.shopGlowInner,
            ]); // Stop all glow tweens

            // Stop camera follow for cinematic control
            this.cameras.main.stopFollow();

            this.startCinematic();
          }
        }

        showNPCHint() {
          // Immediate flag set to prevent race conditions
          if (this.npcDialogueActive) return;
          this.npcDialogueActive = true;

          // Don't show if dialogue already visible
          if (this.dialogueBox) {
            this.npcDialogueActive = false;
            return;
          }

          const hints = [
            "Dying just sends you home with embers!",
            "The beasts grow stronger\nas you get tougher!",
            "Feed the fire, grow your power~",
            "Every run teaches something new,\nlittle penguin!",
            "Courage and cozy fire = victory!\n",
            "Ice beasts drop delicious... I mean,\nvaluable embers!",
            "The wasteland holds many mysteries...\nand lots of snow!",
            "Click the glowing zones to interact!",
            "More embers = stronger penguin!\nIt's that simple~",
            "Take breaks! The ice will wait.",
          ];

          const randomHint = Phaser.Math.RND.pick(hints);
          this.showDialogue(randomHint, () => {
            this.npcDialogueActive = false;
          });
        }

        showDialogue(text, callback) {
          // ALWAYS stop any existing NPC sound first (regardless of dialogue state)
          if (this.currentNPCSound && this.currentNPCSound.stop) {
            this.currentNPCSound.stop();
            this.currentNPCSound = null;
          }

          // Stop any existing dialogue and sounds
          if (this.dialogueBox) {
            // Clean up existing dialogue
            this.dialogueBox.bg.destroy();
            this.dialogueBox.text.destroy();
            this.dialogueBox.continue.destroy();
            if (this.dialogueBox.typewriterEvent) {
              this.dialogueBox.typewriterEvent.remove();
            }
            this.dialogueBox = null;
          }

          // Play random NPC talking sound
          const npcSounds = [
            "npctalking1",
            "npctalking2",
            "npctalking3",
            "npctalking4",
            "npctalking5",
            "npctalking6",
          ];
          const randomSound = Phaser.Math.RND.pick(npcSounds);
          const soundInstance = this.sound.play(randomSound, { volume: 0.7 });
          if (soundInstance) {
            this.currentNPCSound = soundInstance;
          }

          // Create rounded white dialogue box
          const boxBg = this.add.graphics();
          boxBg.fillStyle(0xffffff, 0.95);
          boxBg.fillRoundedRect(20, 50, 360, 100, 16); // x, y, width, height, radius
          boxBg.setScrollFactor(0);
          boxBg.setDepth(400);
          boxBg.setAlpha(0); // Start invisible

          const dialogueText = this.add.text(200, 100, "", {
            fontFamily: "Fobble",
            fontSize: "28px",
            color: "#000000", // Black text on white background
            align: "center",
            wordWrap: { width: 320 },
          });
          dialogueText.setOrigin(0.5);
          dialogueText.setScrollFactor(0);
          dialogueText.setDepth(401);
          dialogueText.setAlpha(0); // Start invisible

          const continueText = this.add.text(200, 275, "...", {
            fontFamily: "Fobble",
            fontSize: "10px",
            color: "#666666", // Darker gray for visibility on white
            align: "center",
          });
          continueText.setOrigin(0.5);
          continueText.setScrollFactor(0);
          continueText.setDepth(401);
          continueText.setVisible(false); // Hide until typing complete
          continueText.setAlpha(0); // Start invisible

          this.dialogueBox = {
            bg: boxBg,
            text: dialogueText,
            continue: continueText,
            typewriterEvent: null, // Will store the typewriter event
          };

          // Fade in dialogue box and text
          this.tweens.add({
            targets: [boxBg, dialogueText],
            alpha: 1,
            duration: 300,
            ease: "Power2.easeOut",
          });

          // Typewriter effect
          let currentChar = 0;
          const typewriterSpeed = 30; // milliseconds per character
          const totalDuration = text.length * typewriterSpeed;

          this.dialogueBox.typewriterEvent = this.time.addEvent({
            delay: typewriterSpeed,
            callback: () => {
              if (currentChar < text.length) {
                dialogueText.setText(text.substring(0, currentChar + 1));
                currentChar++;
              } else {
                if (this.dialogueBox.typewriterEvent) {
                  this.dialogueBox.typewriterEvent.remove();
                }
                // Show continue prompt and start blinking when typing complete
                continueText.setVisible(true);

                // Fade in continue text
                this.tweens.add({
                  targets: continueText,
                  alpha: 1,
                  duration: 200,
                  ease: "Power2.easeOut",
                });

                this.tweens.add({
                  targets: continueText,
                  alpha: 0.3,
                  duration: 500,
                  yoyo: true,
                  repeat: -1,
                });
              }
            },
            loop: true,
          });

          // Auto-advance after typing completes + delay
          this.time.delayedCall(totalDuration + 2000, () => {
            if (this.dialogueBox && !this.dialogueClosing) {
              this.dialogueClosing = true; // Prevent multiple close actions
              if (this.dialogueBox.typewriterEvent) {
                this.dialogueBox.typewriterEvent.remove(); // Clean up event
              }

              // Stop any existing tweens on dialogue elements
              this.tweens.killTweensOf([
                this.dialogueBox.bg,
                this.dialogueBox.text,
                this.dialogueBox.continue,
              ]);

              // Fade out dialogue elements before destroying
              this.tweens.add({
                targets: [
                  this.dialogueBox.bg,
                  this.dialogueBox.text,
                  this.dialogueBox.continue,
                ],
                alpha: 0,
                duration: 200,
                ease: "Power2.easeOut",
                onComplete: () => {
                  if (this.dialogueBox) {
                    // Stop NPC sound if it exists
                    if (this.currentNPCSound && this.currentNPCSound.stop) {
                      this.currentNPCSound.stop();
                      this.currentNPCSound = null;
                    }
                    // Clean up typewriter event if it exists
                    if (this.dialogueBox.typewriterEvent) {
                      this.dialogueBox.typewriterEvent.remove();
                    }
                    this.dialogueBox.bg.destroy();
                    this.dialogueBox.text.destroy();
                    this.dialogueBox.continue.destroy();
                    this.dialogueBox = null;
                  }
                  this.npcDialogueActive = false;
                  this.dialogueClosing = false; // Reset flag
                },
              });
            }
            if (callback) callback();
          });
        }

        startCinematic() {
          this.cinematicPlaying = true;

          // Step 1: Set camera at NPC position immediately
          this.cameras.main.scrollX = this.npc.x - 200; // Center on NPC

          this.time.delayedCall(500, () => {
            this.showDialogue(
              "Welcome little one,\nThe frost creatures\ngrow bold...",
              () => {
                // Step 2: Zoom to shop/fire
                this.cameras.main.pan(180, 300, 1500, "Sine.easeInOut");

                this.time.delayedCall(1500, () => {
                  // Show and play fire animation (loops continuously)
                  this.shopFire.setVisible(true);
                  this.shopFire.play("fireIgnite");
                  this.shopFire2.setVisible(true);
                  this.shopFire2.play("fireIgnite2");

                  // Play fire spell sound for first-time introduction
                  this.sound.play("FireSpellFx", { volume: 0.7 });

                  // Start fire crackling sound after spell effect (1 second delay)
                  this.time.delayedCall(2000, () => {
                    this.fireCracklingSound = this.sound.add(
                      "FireCracklingFx",
                      { loop: true, volume: 0.45 }
                    );
                    this.fireCracklingSound.play();
                  });

                  // Start glow effect after first animation cycle (8 frames at 12fps = 667ms)
                  this.time.delayedCall(667, () => {
                    // Start multi-layer glow effect with staggered timing

                    // Outer glow - appears first, slow
                    this.tweens.add({
                      targets: this.shopGlowOuter,
                      alpha: { from: 0, to: 0.15 },
                      scale: { from: 0.6, to: 1 },
                      duration: 1000,
                      ease: "Power2",
                      onComplete: () => {
                        this.tweens.add({
                          targets: this.shopGlowOuter,
                          scale: 1.4,
                          alpha: 0.25,
                          duration: 2000,
                          yoyo: true,
                          repeat: -1,
                          ease: "Sine.easeInOut",
                        });
                      },
                    });

                    // Middle glow - appears second
                    this.tweens.add({
                      targets: this.shopGlowMiddle,
                      alpha: { from: 0, to: 0.25 },
                      scale: { from: 0.5, to: 1 },
                      duration: 800,
                      delay: 200,
                      ease: "Power2",
                      onComplete: () => {
                        this.tweens.add({
                          targets: this.shopGlowMiddle,
                          scale: 1.3,
                          alpha: 0.4,
                          duration: 1200,
                          yoyo: true,
                          repeat: -1,
                          ease: "Sine.easeInOut",
                        });
                      },
                    });

                    // Inner glow - appears last, bright
                    this.tweens.add({
                      targets: this.shopGlowInner,
                      alpha: { from: 0, to: 0.4 },
                      scale: { from: 0.3, to: 1 },
                      duration: 600,
                      delay: 400,
                      ease: "Power2",
                      onComplete: () => {
                        this.tweens.add({
                          targets: this.shopGlowInner,
                          scale: 1.2,
                          alpha: 0.6,
                          duration: 800,
                          yoyo: true,
                          repeat: -1,
                          ease: "Sine.easeInOut",
                        });
                      },
                    });

                    // Wait 3 seconds to admire the burning fire, then show dialogue
                    this.time.delayedCall(2000, () => {
                      this.showDialogue(
                        "This is your eternal flame!\nToss embers in to\ngain cozy powers~",
                        () => {
                          // Step 3: Zoom to exit
                          this.cameras.main.pan(
                            this.archX,
                            300,
                            1500,
                            "Sine.easeInOut"
                          );

                          this.time.delayedCall(1000, () => {
                            this.showDialogue(
                              "Beyond lies the\nfrozen battlefield...\n A place for the brave.",
                              () => {
                                // Step 4: Back to NPC for final message
                                this.cameras.main.pan(
                                  this.npc.x,
                                  300,
                                  1500,
                                  "Sine.easeInOut"
                                );

                                this.time.delayedCall(1000, () => {
                                  this.showDialogue(
                                    "Bop those ice beasts!\nCollect embers!\nI'll revive you if you die!",
                                    () => {
                                      // End cinematic - smoothly transition camera to player
                                      this.time.delayedCall(500, () => {
                                        // Pan to player position first
                                        this.cameras.main.pan(
                                          this.player.x,
                                          300,
                                          1000,
                                          "Sine.easeInOut",
                                          false,
                                          (camera, progress) => {
                                            // When pan completes, start following
                                            if (progress === 1) {
                                              this.cameras.main.startFollow(
                                                this.player,
                                                false,
                                                0.1,
                                                0
                                              );
                                              this.cameras.main.setDeadzone(
                                                150,
                                                600
                                              );
                                              this.cinematicPlaying = false;

                                              // Create joystick now that cinematic is over
                                              this.createMobileJoystick();

                                              // Show UI elements with updated values
                                              // this.titleText.setVisible(true);
                                              this.statsText.setVisible(false);
                                              this.statsText.setText(
                                                `Runs: ${GameRegistry.totalRuns} | Best: ${GameRegistry.bestWave}`
                                              );
                                              this.backpackSprite.setVisible(
                                                true
                                              );
                                              this.backpackSprite2.setVisible(
                                                true
                                              );
                                              this.backpackEmberText.setVisible(
                                                true
                                              );
                                              if (this.backpackParticles)
                                                this.backpackParticles.setVisible(
                                                  true
                                                );

                                              // Show joystick when backpack appears (first-time only)
                                              if (
                                                this.joystick &&
                                                this.joystick.base &&
                                                this.joystick.knob
                                              ) {
                                                this.joystick.base.setVisible(
                                                  true
                                                );
                                                this.joystick.knob.setVisible(
                                                  true
                                                );
                                              }
                                              if (this.backpackYellowParticles)
                                                this.backpackYellowParticles.setVisible(
                                                  true
                                                );
                                            }
                                          }
                                        );
                                      });
                                    }
                                  );
                                });
                              }
                            );
                          });
                        }
                      );
                    });
                  });
                });
              }
            );
          });
        }

        shutdown() {
          // Stop all sounds when scene is destroyed
          this.sound.stopAll();

          // Clean up specific sound references
          if (this.ambientSound) {
            this.ambientSound.destroy();
          }
          if (this.HubMusic) {
            this.HubMusic.destroy();
          }
          if (this.fireCracklingSound) {
            this.fireCracklingSound.destroy();
          }
          if (this.currentNPCSound) {
            this.currentNPCSound.destroy();
          }
        }

        createMobileJoystick() {
          // Always create joystick (no mobile detection)
          // this.input.addPointer(2); // Add second pointer for multi-touch

          const joystickSize = 60;
          const knobSize = 20;
          const joystickX = 90; // 10px more to the right
          const joystickY = this.cameras.main.height - 90; // 10px more to the top

          // Track joystick input (like keyboard isDown) - binary states
          this.mobileInput = {
            up: false,
            down: false,
            left: false,
            right: false,
          };

          // Joystick properties
          this.joystick = {
            base: null,
            knob: null,
            isActive: false,
            centerX: joystickX,
            centerY: joystickY,
            maxDistance: joystickSize - knobSize - 5,
            activePointer: null,
          };

          // Create joystick base (outer circle) - brand colors
          this.joystick.base = this.add
            .circle(joystickX, joystickY, joystickSize, 0x00142d, 0.4)
            .setDepth(1)
            .setScrollFactor(0)
            .setStrokeStyle(4, 0x477dfd, 0.45)
            .setInteractive({ useHandCursor: false });

          // Create joystick knob (inner circle) - brand colors
          this.joystick.knob = this.add
            .circle(joystickX, joystickY, knobSize, 0x80abff, 0.45)
            .setDepth(2)
            .setScrollFactor(0)
            .setStrokeStyle(3, 0x477dfd, 0.5)
            .setInteractive({ useHandCursor: false });

          // Hide joystick initially on first-time playthroughs
          const isFirstTime = GameRegistry.totalRuns === 0;
          if (isFirstTime) {
            this.joystick.base.setVisible(false);
            this.joystick.knob.setVisible(false);
          }

          // Joystick input handling - base events
          this.joystick.base.on("pointerdown", (pointer) => {
            this.joystick.isActive = true;
            this.joystick.activePointer = pointer;
            this.updateJoystickInput(pointer);
          });

          this.joystick.base.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          this.joystick.base.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });

          // Also handle knob events for better touch response
          this.joystick.knob.on("pointerdown", (pointer) => {
            this.joystick.isActive = true;
            this.joystick.activePointer = pointer;
            this.updateJoystickInput(pointer);
          });

          this.joystick.knob.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          this.joystick.knob.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });

          // Global pointerup to handle finger lifted outside joystick area
          this.input.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          // Global pointermove to handle finger movement anywhere on screen
          this.input.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });
        }

        updateJoystickInput(pointer) {
          const deltaX = pointer.x - this.joystick.centerX;
          const deltaY = pointer.y - this.joystick.centerY;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          // Reset all directions first
          this.mobileInput.up = false;
          this.mobileInput.down = false;
          this.mobileInput.left = false;
          this.mobileInput.right = false;

          // Only set directions if we're far enough from center (like pressing a key)
          if (distance > 15) {
            // Dead zone - must move at least 15 pixels from center
            // Allow diagonal movement by checking each axis independently

            // Horizontal movement
            if (Math.abs(deltaX) > 15) {
              if (deltaX < 0) {
                this.mobileInput.left = true; // Like pressing left arrow key
              } else {
                this.mobileInput.right = true; // Like pressing right arrow key
              }
            }

            // Vertical movement
            if (Math.abs(deltaY) > 15) {
              if (deltaY < 0) {
                this.mobileInput.up = true; // Like pressing up arrow key
              } else {
                this.mobileInput.down = true; // Like pressing down arrow key
              }
            }
          }

          // Update knob position (constrained to joystick area)
          if (distance <= this.joystick.maxDistance) {
            this.joystick.knob.setPosition(pointer.x, pointer.y);
          } else {
            const angle = Math.atan2(deltaY, deltaX);
            const constrainedX =
              this.joystick.centerX +
              Math.cos(angle) * this.joystick.maxDistance;
            const constrainedY =
              this.joystick.centerY +
              Math.sin(angle) * this.joystick.maxDistance;
            this.joystick.knob.setPosition(constrainedX, constrainedY);
          }
        }

        resetJoystickInput() {
          // Reset all directions (like releasing all keys)
          this.mobileInput.up = false;
          this.mobileInput.down = false;
          this.mobileInput.left = false;
          this.mobileInput.right = false;

          // Stop player movement immediately
          if (this.player && this.player.body) {
            this.player.body.setVelocity(0, 0);
          }

          // Smooth return to center
          this.tweens.add({
            targets: this.joystick.knob,
            x: this.joystick.centerX,
            y: this.joystick.centerY,
            duration: 200,
            ease: "Back.easeOut",
          });
        }

        update() {
          if (!this.player || this.shopOpen || this.cinematicPlaying) return;

          // Horizontal movement only (belt-scroller)
          let velocityX = 0;

          if (
            this.cursors.left.isDown ||
            this.wasd.A.isDown ||
            (this.mobileInput && this.mobileInput.left)
          ) {
            velocityX = -200;
            this.player.setFlipX(true); // Face left
            this.player.anims.play("walk", true);
          } else if (
            this.cursors.right.isDown ||
            this.wasd.D.isDown ||
            (this.mobileInput && this.mobileInput.right)
          ) {
            velocityX = 200;
            this.player.setFlipX(false); // Face right
            this.player.anims.play("walk", true);
          } else {
            // Stop animation when not moving
            this.player.anims.play("idle", true);
            // this.player.setFrame(0); // Reset to first frame
          }

          this.player.body.setVelocity(velocityX, 0);

          // Check proximity to shop
          const distToShop = Phaser.Math.Distance.Between(
            this.player.x,
            this.player.y,
            this.shopZone.x,
            this.shopZone.y
          );

          // Check proximity to door
          const distToDoor = Phaser.Math.Distance.Between(
            this.player.x,
            this.player.y,
            this.doorZone.x,
            this.doorZone.y
          );

          // Check proximity to NPC
          const distToNPC = Phaser.Math.Distance.Between(
            this.player.x,
            this.player.y,
            this.npc.x,
            this.npc.y
          );

          this.nearNPC = distToNPC < 80;

          // Check if near interactive zones
          if (distToShop < 80) {
            this.nearShop = true;
            this.nearDoor = false;
          } else if (distToDoor < 80) {
            this.nearDoor = true;
            this.nearShop = false;
          } else {
            this.nearShop = false;
            this.nearDoor = false;
          }

          // NPC visual feedback when near
          if (this.nearNPC) {
            this.npc.setAlpha(1);
          } else {
            this.npc.setAlpha(0.8);
          }

          // Floating text for interactive zones
          this.updateFloatingText();
        }

        updateFloatingText() {
          // Shop floating text and glow scaling
          if (
            this.nearShop &&
            !this.shopFloatingText &&
            !this.shopOpen &&
            !this.shopFloatingTextFading
          ) {
            this.shopFloatingText = this.add.sprite(290, 320, "tapcursor");
            this.shopFloatingText.setDepth(50);
            this.shopFloatingText.setScale(0.4);
            this.shopFloatingText.setAlpha(0);
            this.shopFloatingText.play("tapcursorAnim");

            // Fade in animation
            this.tweens.add({
              targets: this.shopFloatingText,
              alpha: 1,
              duration: 300,
              ease: "Power2.easeOut",
            });

            // Scale up shop glow when near
            this.tweens.add({
              targets: [
                this.shopGlowOuter,
                this.shopGlowMiddle,
                this.shopGlowInner,
              ],
              scale: 1.0,
              duration: 300,
              ease: "Power2.easeOut",
            });
          } else if (
            !this.nearShop &&
            this.shopFloatingText &&
            !this.shopFloatingTextFading
          ) {
            // Stop any existing tweens on this text
            this.tweens.killTweensOf(this.shopFloatingText);
            this.shopFloatingTextFading = true;

            // Fade out floating text before destroying
            this.tweens.add({
              targets: this.shopFloatingText,
              alpha: 0,
              duration: 200,
              ease: "Power2.easeOut",
              onComplete: () => {
                if (this.shopFloatingText) {
                  this.shopFloatingText.destroy();
                  this.shopFloatingText = null;
                }
                this.shopFloatingTextFading = false;
              },
            });

            // Scale down shop glow when away
            this.tweens.add({
              targets: [
                this.shopGlowOuter,
                this.shopGlowMiddle,
                this.shopGlowInner,
              ],
              scale: 0.5,
              duration: 300,
              ease: "Power2.easeOut",
            });
          }

          // Door floating text and glow scaling
          if (
            this.nearDoor &&
            !this.doorFloatingText &&
            !this.doorFloatingTextFading
          ) {
            this.doorFloatingText = this.add.sprite(
              this.archX,
              320,
              "tapcursor"
            );
            this.doorFloatingText.setDepth(50);
            this.doorFloatingText.setScale(0.4);
            this.doorFloatingText.setAlpha(0);
            this.doorFloatingText.play("tapcursorAnim");

            // Fade in animation
            this.tweens.add({
              targets: this.doorFloatingText,
              alpha: 1,
              duration: 300,
              ease: "Power2.easeOut",
            });

            // Scale up door glow when near
            this.tweens.add({
              targets: [
                this.doorGlowOuter,
                this.doorGlowMiddle,
                this.doorGlowInner,
              ],
              scale: 1.0,
              duration: 300,
              ease: "Power2.easeOut",
            });
          } else if (
            !this.nearDoor &&
            this.doorFloatingText &&
            !this.doorFloatingTextFading
          ) {
            // Stop any existing tweens on this text
            this.tweens.killTweensOf(this.doorFloatingText);
            this.doorFloatingTextFading = true;

            // Fade out floating text before destroying
            this.tweens.add({
              targets: this.doorFloatingText,
              alpha: 0,
              duration: 200,
              ease: "Power2.easeOut",
              onComplete: () => {
                if (this.doorFloatingText) {
                  this.doorFloatingText.destroy();
                  this.doorFloatingText = null;
                }
                this.doorFloatingTextFading = false;
              },
            });

            // Scale down door glow when away
            this.tweens.add({
              targets: [
                this.doorGlowOuter,
                this.doorGlowMiddle,
                this.doorGlowInner,
              ],
              scale: 0.5,
              duration: 300,
              ease: "Power2.easeOut",
            });
          }
        }

        openShop() {
          this.shopOpen = true;
          this.player.body.setVelocity(0); // Stop player movement

          // Hide floating text when shop opens
          if (this.shopFloatingText) {
            this.shopFloatingText.destroy();
            this.shopFloatingText = null;
          }

          // Check if we should show tutorial cursor (no upgrades purchased yet)
          const hasAnyUpgrades = Object.values(GameRegistry.upgrades).some(
            (value) => value > 0
          );
          this.showTutorialCursor = !hasAnyUpgrades;

          // Fade out the game world
          this.cameras.main.fadeOut(300, 0, 0, 0);

          // Create the shop UI after fade
          this.time.delayedCall(300, () => {
            this.createShopUI();
            // Fade back in to show shop
            this.cameras.main.fadeIn(300, 0, 0, 0);
          });
        }

        createBackpackUI() {
          // Backpack sprite in bottom right
          this.backpackSprite = this.add.image(330, 540, "backpack");
          this.backpackSprite.setScale(1);
          this.backpackSprite.setScrollFactor(0); // Fixed to camera
          this.backpackSprite.setDepth(400);
          this.backpackSprite.setAlpha(0.5);

          this.backpackSprite2 = this.add.image(330, 540, "backpack2");
          this.backpackSprite2.setScale(1);
          this.backpackSprite2.setScrollFactor(0); // Fixed to camera
          this.backpackSprite2.setDepth(405);

          // Ember count text on backpack
          this.backpackEmberText = this.add.text(
            330,
            570,
            `${GameRegistry.embers}`,
            {
              fontSize: "20px",
              fontFamily: "Fobble",
              color: "#ff8b8b",
              stroke: "#000000",
              strokeThickness: 3,
            }
          );
          this.backpackEmberText.setOrigin(0.5);
          this.backpackEmberText.setScrollFactor(0); // Fixed to camera
          this.backpackEmberText.setDepth(406);

          // Create fire sprites on backpack
          this.createBackpackFire();
        }

        createBackpackFire() {
          // Main fire sprite on backpack
          this.backpackFire = this.add.sprite(330, 530, "shopFire");
          this.backpackFire.setScale(0.3); // Start small
          this.backpackFire.setScrollFactor(0); // Fixed to camera
          this.backpackFire.setDepth(402);
          this.backpackFire.setAlpha(0.7);

          // Secondary fire sprite on backpack
          this.backpackFire2 = this.add.sprite(330, 530, "shopFire2");
          this.backpackFire2.setScale(0.25); // Start small
          this.backpackFire2.setScrollFactor(0); // Fixed to camera
          this.backpackFire2.setDepth(403);
          this.backpackFire2.setAlpha(0.6);

          // Play fire animations
          this.backpackFire.play("fireIgnite", true);
          this.backpackFire2.play("fireIgnite2", true);

          // Update fire scale based on ember count
          this.updateBackpackFire();
        }

        updateBackpackFire() {
          if (!this.backpackFire || !this.backpackFire2) return;

          const emberCount = GameRegistry.embers;
          const intensity = Math.min(emberCount / 200, 1); // Scale from 0-1 based on embers (0-200)

          // Calculate scale based on ember count
          const minScale = 0.01;
          const maxScale = 0.35;
          const scale = minScale + intensity * (maxScale - minScale);

          // Update fire scales
          this.backpackFire.setScale(scale);
          this.backpackFire2.setScale(scale * 0.8); // Slightly smaller than main fire

          // Update alpha based on intensity
          this.backpackFire.setAlpha(0.6 + intensity * 0.4); // 0.6 to 1.0
          this.backpackFire2.setAlpha(0.5 + intensity * 0.3); // 0.5 to 0.8
        }

        updateBackpackDisplay() {
          if (!this.backpackEmberText) return;

          // Update ember count text
          this.backpackEmberText.setText(`${GameRegistry.embers}`);

          // Update fire intensity
          this.updateBackpackFire();
        }

        closeShop(shopItems) {
          // Fade out the shop
          this.cameras.main.fadeOut(300, 0, 0, 0);

          // Clean up after fade
          this.time.delayedCall(300, () => {
            shopItems.forEach((item) => item.destroy());
            this.shopOpen = false;

            // Reset tutorial cursor state when shop closes
            this.showTutorialCursor = false;

            // Destroy any active confetti when shop closes
            if (this.activeConfetti) {
              this.activeConfetti.destroy();
              this.activeConfetti = null;
            }

            // Fade back in to show game world
            this.cameras.main.fadeIn(300, 0, 0, 0);
          });
        }

        startGameTransition() {
          // Stop all sounds before transitioning to game
          this.sound.stopAll();

          // Disable input during transition
          this.input.enabled = false;

          // Zoom in and fade out
          this.tweens.add({
            targets: this.cameras.main,
            zoom: 1.5,
            duration: 1000,
            ease: "Power2.easeIn",
          });
          this.cameras.main.fadeOut(1000, 0, 0, 0);

          // After fade completes, start game scene
          this.time.delayedCall(1000, () => {
            this.scene.start("GameScene");
          });
        }

        refreshShop() {
          // Update the shop UI to show newly unlocked upgrades
          if (this.shopOpen) {
            // Find all current shop items and destroy them
            const currentShopItems = this.children.list.filter(
              (child) =>
                child.scrollFactorX === 0 &&
                child.scrollFactorY === 0 &&
                child.depth >= 200 &&
                child.depth <= 300
            );

            currentShopItems.forEach((item) => {
              if (item.destroy) item.destroy();
            });

            // Recreate the shop UI with updated unlock status
            this.createShopUI();
          }
        }

        createConfettiEffect() {
          // Create confetti particle texture if it doesn't exist
          if (!this.textures.exists("confettiTexture")) {
            const texture = this.textures.createCanvas("confettiTexture", 8, 8);
            const context = texture.getContext();
            context.fillStyle = "#ffffff";
            context.fillRect(0, 0, 8, 8);
            texture.refresh();
          }

          // Create confetti particles at camera position
          const confetti = this.add.particles(
            this.cameras.main.centerX,
            this.cameras.main.centerY,
            "confettiTexture",
            {
              emitZone: {
                type: "random",
                quantity: 1,
                source: new Phaser.Geom.Rectangle(-200, -300, 700, 1),
              },
              speedY: { min: 200, max: 400 },
              speedX: { min: -150, max: 150 },
              accelerationY: { min: 50, max: 100 },
              lifespan: { min: 2000, max: 3500 },
              scaleX: {
                onUpdate: (particle, key, t) => {
                  return Math.sin((t / 1) * Math.PI * 8);
                },
              },
              blendMode: "ADD",
              rotate: { min: -180, max: 180 },
              frequency: 30,
              quantity: 3,
              tint: [
                0xff6b35, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xf0932b, 0xeb4d4b,
                0x6c5ce7, 0xa29bfe,
              ],
              alpha: { start: 1, end: 0 },
              scale: { start: 0.8, end: 0.2 },
            }
          );

          // Store reference to active confetti for cleanup
          this.activeConfetti = confetti;

          // Set confetti depth to appear above shop overlay but below buttons
          confetti.setDepth(201);

          // Stop emitting confetti after 1 second
          this.time.delayedCall(1000, () => {
            if (confetti) {
              confetti.stop();
            }
          });

          // Destroy confetti emitter after all particles have fallen off-screen
          this.time.delayedCall(3000, () => {
            if (confetti) {
              confetti.destroy();
              this.activeConfetti = null;
            }
          });
        }

        createShopUI() {
          // Helper function to get upgrade paths with dynamic unlock status
          const getUpgradePaths = () => [
            {
              name: "🔥 Fire Path",
              color: 0xff4500,
              upgrades: [
                {
                  name: "Ember Efficiency",
                  key: "emberEfficiency",
                  cost: 300,
                  maxLevel: 1,
                  desc: "Start each run with +50 embers",
                  unlocked: true, // First upgrade is always unlocked
                },
                {
                  name: "Burning Bullets",
                  key: "burningBullets",
                  cost: 400,
                  maxLevel: 1,
                  desc: "Bullets deal 2 damage/sec for 3s",
                  unlocked: GameRegistry.upgrades.emberEfficiency > 0,
                },
                {
                  name: "Fire Nova",
                  key: "fireTotem",
                  cost: 500,
                  maxLevel: 1,
                  desc: "Chance to emit fire nova on hit",
                  unlocked: GameRegistry.upgrades.burningBullets > 0,
                },
                {
                  name: "Phoenix Rebirth",
                  key: "phoenixRebirth",
                  cost: 800,
                  maxLevel: 1,
                  desc: "25% chance to revive when dying",
                  unlocked: GameRegistry.upgrades.fireTotem > 0,
                },
              ],
            },
            {
              name: "🧊 Ice Path",
              color: 0x00aaff,
              upgrades: [
                {
                  name: "Cold Resistance",
                  key: "coldResistance",
                  cost: 500,
                  maxLevel: 1,
                  desc: "Take 10% less damage",
                  unlocked: true, // First upgrade is always unlocked
                },
                {
                  name: "Ice Armor",
                  key: "iceArmor",
                  cost: 600,
                  maxLevel: 1,
                  desc: "Take 20% less damage",
                  unlocked: GameRegistry.upgrades.coldResistance > 0,
                },
                {
                  name: "Frost Bullets",
                  key: "frostBullets",
                  cost: 700,
                  maxLevel: 1,
                  desc: "Bullets slow enemies permanently",
                  unlocked: GameRegistry.upgrades.iceArmor > 0,
                },
                {
                  name: "Blizzard",
                  key: "blizzard",
                  cost: 800,
                  maxLevel: 1,
                  desc: "Deal damage to nearby enemies",
                  unlocked: GameRegistry.upgrades.frostBullets > 0,
                },
              ],
            },
            {
              name: "🐧 Penguin Path",
              color: 0x4caf50,
              upgrades: [
                {
                  name: "Waddle Mastery",
                  key: "waddleMastery",
                  cost: 450,
                  maxLevel: 1,
                  desc: "Move 10% faster",
                  unlocked: true, // First upgrade is always unlocked
                },
                {
                  name: "Slip Stream",
                  key: "bellySlide",
                  cost: 700,
                  maxLevel: 1,
                  desc: "Move 20% faster when low health",
                  unlocked: GameRegistry.upgrades.waddleMastery > 0,
                },
                {
                  name: "Fish Feast",
                  key: "fishFeast",
                  cost: 900,
                  maxLevel: 1,
                  desc: "Chance to gain health from embers",
                  unlocked: GameRegistry.upgrades.bellySlide > 0,
                },
                {
                  name: "Pack Leader",
                  key: "packLeader",
                  cost: 1200,
                  maxLevel: 1,
                  desc: "1 penguin ally collects embers",
                  unlocked: GameRegistry.upgrades.fishFeast > 0,
                },
              ],
            },
          ];

          const upgradePaths = getUpgradePaths();

          // Darken background - fixed to camera with rounded corners
          const overlay = this.add.graphics();
          overlay.fillStyle(0x000000, 0.9);
          overlay.fillRect(0, 0, 400, 600);

          overlay.setScrollFactor(0);
          overlay.setDepth(200);

          // Shop panel - fixed to camera with rounded corners

          const shopItems = [overlay];

          let currentY = 70;

          upgradePaths.forEach((path, pathIndex) => {
            // Calculate path progress
            let purchasedCount = 0;
            let totalCount = path.upgrades.length;
            path.upgrades.forEach((upgrade) => {
              const currentLevel = GameRegistry.upgrades[upgrade.key] || 0;
              if (currentLevel >= upgrade.maxLevel) {
                purchasedCount++;
              }
            });

            // Path header with progress
            const pathHeader = this.add.text(
              20,
              currentY - 5,
              `${path.name} (${purchasedCount}/${totalCount})`,
              {
                fontSize: "28px",
                fontFamily: "Fobble",
                color: `#${path.color.toString(16).padStart(6, "0")}`,
                stroke: "#000000",
                strokeThickness: 3,
              }
            );
            pathHeader.setScrollFactor(0);
            pathHeader.setDepth(204);
            shopItems.push(pathHeader);
            currentY += 30;

            // Show MAXED card if path is complete
            if (purchasedCount === totalCount) {
              const maxedCard = this.add.graphics();
              maxedCard.fillStyle(0x4a5568, 0.9);
              maxedCard.lineStyle(4, 0x68d391, 1);
              maxedCard.fillRoundedRect(20, currentY, 360, 80, 15);
              maxedCard.strokeRoundedRect(20, currentY, 360, 80, 15);
              maxedCard.setScrollFactor(0);
              maxedCard.setDepth(203);

              const maxedText = this.add.text(
                200,
                currentY + 40,
                "✨ PATH COMPLETE ✨",
                {
                  fontSize: "24px",
                  fontFamily: "Fobble",
                  color: "#68d391",
                  stroke: "#000000",
                  strokeThickness: 3,
                }
              );
              maxedText.setOrigin(0.5);
              maxedText.setScrollFactor(0);
              maxedText.setDepth(204);

              shopItems.push(maxedCard, maxedText);
              currentY += 100; // Skip to next path
              return; // Skip showing individual upgrades for this path
            }

            // Path upgrades - only show unlocked ones that aren't maxed
            let unlockedCount = 0;
            path.upgrades.forEach((upgrade, upgradeIndex) => {
              // Check if upgrade is unlocked
              const isUnlocked = upgrade.unlocked;
              const currentLevel = GameRegistry.upgrades[upgrade.key] || 0;
              const isMaxed = currentLevel >= upgrade.maxLevel;

              // Only show unlocked upgrades that aren't maxed out
              if (!isUnlocked || isMaxed) return;

              const y = currentY + unlockedCount * 80;

              // Upgrade box background - full width
              const upgradeBox = this.add.graphics();
              upgradeBox.fillStyle(0xf0f0f0, 0.9);
              upgradeBox.lineStyle(3, 0x333333, 1);
              upgradeBox.fillRoundedRect(20, y, 360, 70, 15);
              upgradeBox.strokeRoundedRect(20, y, 360, 70, 15);
              upgradeBox.setScrollFactor(0);
              upgradeBox.setDepth(202);

              // Upgrade name
              const nameText = this.add.text(30, y + 10, upgrade.name, {
                fontSize: "34px",
                fontFamily: "Fobble",
                color: "#333333",
                stroke: "#000000",
                strokeThickness: 2,
              });
              nameText.setScrollFactor(0);
              nameText.setDepth(204);

              // Upgrade description
              const descText = this.add.text(30, y + 42, upgrade.desc, {
                fontSize: "22px",
                fontFamily: "Fobble",
                color: "#666666",
                stroke: "#000000",
                strokeThickness: 1,
                wordWrap: { width: 280 },
              });
              descText.setScrollFactor(0);
              descText.setDepth(204);

              // Buy button - positioned on the right
              const buyBtn = this.add.graphics();
              const canAfford = GameRegistry.embers >= upgrade.cost;

              // Set initial button style based on affordability
              if (canAfford) {
                buyBtn.fillStyle(0x4caf50, 0.9);
                buyBtn.lineStyle(2, 0x2e7d32, 1);
              } else {
                buyBtn.fillStyle(0x666666, 0.6);
                buyBtn.lineStyle(2, 0x333333, 1);
              }
              buyBtn.fillRoundedRect(300, y + 15, 70, 40, 8);
              buyBtn.strokeRoundedRect(300, y + 15, 70, 40, 8);
              buyBtn.setScrollFactor(0);
              buyBtn.setDepth(204);

              // Buy button text
              const buyText = this.add.text(335, y + 35, `${upgrade.cost}`, {
                fontSize: "32px",
                fontFamily: "Fobble",
                color: canAfford ? "#ffffff" : "#999999",
                stroke: "#000000",
                strokeThickness: 3,
              });
              buyText.setOrigin(0.5);
              buyText.setScrollFactor(0);
              buyText.setDepth(205);

              // Create progress bar for hold-to-buy mechanic
              const progressBar = this.add.graphics();
              progressBar.setScrollFactor(0);
              progressBar.setDepth(203); // Behind text (203) but above upgrade box (203)
              progressBar.setVisible(false);

              // Make buy button interactive
              buyBtn.setInteractive(
                new Phaser.Geom.Rectangle(300, y + 15, 70, 40),
                Phaser.Geom.Rectangle.Contains
              );

              // Hold-to-buy variables
              let holdProgress = 0;
              let holdTimer = null;
              let isHolding = false;
              const holdDuration = 1500; // 1.5 seconds to complete purchase

              // Only add hover effects if player can afford the upgrade
              if (canAfford) {
                buyBtn.on("pointerover", () => {
                  if (!isHolding) {
                    buyBtn.clear();
                    buyBtn.fillStyle(0x66bb6a, 0.9);
                    buyBtn.lineStyle(2, 0x388e3c, 1);
                    buyBtn.fillRoundedRect(300, y + 15, 70, 40, 8);
                    buyBtn.strokeRoundedRect(300, y + 15, 70, 40, 8);
                  }
                });

                buyBtn.on("pointerout", () => {
                  if (!isHolding) {
                    buyBtn.clear();
                    buyBtn.fillStyle(0x4caf50, 0.9);
                    buyBtn.lineStyle(2, 0x2e7d32, 1);
                    buyBtn.fillRoundedRect(300, y + 15, 70, 40, 8);
                    buyBtn.strokeRoundedRect(300, y + 15, 70, 40, 8);
                  } else {
                    // Cancel purchase if pointer leaves button while holding
                    isHolding = false;
                    holdProgress = 0;
                    progressBar.setVisible(false);
                    if (holdTimer) {
                      holdTimer.destroy();
                      holdTimer = null;
                    }

                    // Reset button appearance
                    buyBtn.clear();
                    buyBtn.fillStyle(0x4caf50, 0.9);
                    buyBtn.lineStyle(2, 0x2e7d32, 1);
                    buyBtn.fillRoundedRect(300, y + 15, 70, 40, 8);
                    buyBtn.strokeRoundedRect(300, y + 15, 70, 40, 8);
                  }
                });

                // Hold-to-buy mechanics
                buyBtn.on("pointerdown", () => {
                  if (GameRegistry.embers >= upgrade.cost) {
                    isHolding = true;
                    holdProgress = 150;

                    // Show progress bar
                    progressBar.setVisible(true);

                    // Start hold timer
                    holdTimer = this.time.addEvent({
                      delay: 16, // ~60fps updates
                      callback: () => {
                        holdProgress += 16;
                        const progressPercent = Math.min(
                          holdProgress / holdDuration,
                          1
                        );

                        // Update progress bar - fill entire upgrade box
                        progressBar.clear();
                        // progress bar color should be based on the upgrade path color
                        const upgradePathColor = path.color;
                        progressBar.fillStyle(upgradePathColor, 0.8);
                        progressBar.fillRoundedRect(
                          20,
                          y,
                          350 * progressPercent,
                          70,
                          20
                        );

                        if (progressPercent >= 1) {
                          // Purchase complete!
                          this.sound.play("ClickFx", { volume: 0.5 });
                          this.sound.play("LevelUpFx", { volume: 0.5 });
                          this.sound.play("FireSpellFx", { volume: 0.7 });

                          GameRegistry.embers -= upgrade.cost;
                          GameRegistry.upgrades[upgrade.key] =
                            (GameRegistry.upgrades[upgrade.key] || 0) + 1;
                          this.updateBackpackDisplay();
                          gameData.saveGameState();

                          // Create confetti effect for successful purchase
                          this.createConfettiEffect();

                          // Hide tutorial cursor after first purchase
                          if (this.showTutorialCursor) {
                            this.showTutorialCursor = false;
                          }

                          // Refresh the shop to show newly unlocked upgrades
                          this.refreshShop();

                          // Reset state
                          isHolding = false;
                          holdProgress = 0;
                          progressBar.setVisible(false);
                          if (holdTimer) {
                            holdTimer.destroy();
                            holdTimer = null;
                          }
                        }
                      },
                      repeat: -1,
                    });
                  }
                });

                buyBtn.on("pointerup", () => {
                  if (isHolding) {
                    // Cancel purchase
                    isHolding = false;
                    holdProgress = 0;
                    progressBar.setVisible(false);
                    if (holdTimer) {
                      holdTimer.destroy();
                      holdTimer = null;
                    }

                    // Reset button appearance
                    buyBtn.clear();
                    buyBtn.fillStyle(0x4caf50, 0.9);
                    buyBtn.lineStyle(2, 0x2e7d32, 1);
                    buyBtn.fillRoundedRect(300, y + 15, 70, 40, 8);
                    buyBtn.strokeRoundedRect(300, y + 15, 70, 40, 8);
                  }
                });
              } else {
                // Disable interaction for unaffordable items
                buyBtn.disableInteractive();
              }

              // Add tutorial tap cursor for first-time players on affordable upgrades
              if (this.showTutorialCursor && canAfford) {
                const tapCursor = this.add.sprite(335, y + 55, "tapcursor");
                tapCursor.setScale(0.3);
                tapCursor.setScrollFactor(0);
                tapCursor.setDepth(300); // Above everything else
                tapCursor.play("tapcursorAnim");

                // Add cursor to cleanup list
                shopItems.push(tapCursor);
              }

              shopItems.push(buyBtn, buyText, progressBar);

              shopItems.push(upgradeBox, nameText, descText);
              unlockedCount++;
            });

            currentY += unlockedCount * 80 + 20; // Add spacing between paths
          });

          // Close button - fixed to camera with rounded corners
          const closeBtn = this.add.graphics();
          closeBtn.fillStyle(0xf56565, 0.9); // Softer red
          closeBtn.lineStyle(3, 0xe53e3e, 1);
          closeBtn.fillRoundedRect(25, 510, 150, 40, 20);
          closeBtn.strokeRoundedRect(25, 510, 150, 40, 20);
          closeBtn.setScrollFactor(0);
          closeBtn.setDepth(203);

          const closeText = this.add
            .text(100, 530, "CLOSE", {
              fontSize: "18px",
              fontFamily: "Fobble",
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 3,
            })
            .setOrigin(0.5);
          closeText.setScrollFactor(0);
          closeText.setDepth(204);

          closeBtn.setInteractive(
            new Phaser.Geom.Rectangle(25, 510, 150, 40),
            Phaser.Geom.Rectangle.Contains
          );

          closeBtn.on("pointerover", () => {
            closeBtn.clear();
            closeBtn.fillStyle(0xff6b6b, 0.9);
            closeBtn.lineStyle(3, 0xe53e3e, 1);
            closeBtn.fillRoundedRect(25, 510, 150, 40, 20);
            closeBtn.strokeRoundedRect(25, 510, 150, 40, 20);
          });

          closeBtn.on("pointerout", () => {
            closeBtn.clear();
            closeBtn.fillStyle(0xf56565, 0.9);
            closeBtn.lineStyle(3, 0xe53e3e, 1);
            closeBtn.fillRoundedRect(25, 510, 150, 40, 20);
            closeBtn.strokeRoundedRect(25, 510, 150, 40, 20);
          });

          closeBtn.on("pointerdown", () => {
            this.sound.play("ClickFx", { volume: 0.5 });
            this.closeShop(shopItems.concat([closeBtn, closeText]));
          });

          shopItems.push(closeBtn, closeText);
        }
      }

      // ===== GAME SCENE (Arena) =====
      class GameScene extends Phaser.Scene {
        player = null;
        cursors = null;
        wasd = {};

        enemies = [];
        bullets = [];
        emberPickups = [];

        playerHealth = 100;
        playerMaxHealth = 100;
        playerSpeed = 100;
        emberCount = 0;
        score = 0;

        // XP System
        currentXP = 0;
        currentLevel = 1;
        xpToNextLevel = 100;
        playerDamage = 25;
        playerFireRate = 500; // Lower = faster shooting

        // Upgrade properties
        critChance = 0;
        multiShot = false;
        scoreMultiplier = 1;
        fowRadiusMultiplier = 1;
        emberMagnet = false;

        // Combo system
        comboCount = 0;
        comboMultiplier = 1;
        lastKillTime = 0;
        comboTimeout = 2000; // 2 seconds between kills to maintain combo

        // Shop upgrade effects
        penguinAllies = [];
        blizzardActive = false;
        blizzardCooldown = 0;
        lastBlizzardTime = 0;

        healthBar = null;
        healthBarBg = null;
        waveText = null;
        scoreText = null;
        xpBar = null;
        xpBarBg = null;
        levelText = null;
        backpackSprite = null;
        backpackSprite2 = null;
        backpackEmberText = null;
        backpackFire = null;
        backpackFire2 = null;

        // Continuous spawning system
        lastEnemySpawn = 0;
        enemySpawnInterval = 2000; // 2 seconds between spawns
        maxEnemies = 8; // Maximum enemies on screen
        gameTime = 0; // Track game time for difficulty scaling

        lastShot = 0;
        shootCooldown = 200;

        constructor() {
          super({ key: "GameScene" });
        }

        create() {
          // Reset state
          this.emberCount = 0;
          this.score = 0;
          this.enemies = [];
          this.bullets = [];
          this.emberPickups = [];
          this.gameTime = 0;
          this.lastEnemySpawn = 0;
          this.penguinAllies = []; // Reset penguin allies
          // Track per-run start time so difficulty scales from 0 each run
          this.runStartTime = this.time.now;

          // Enemy physics group (for enemy-vs-enemy collisions)
          this.enemiesGroup = this.physics.add.group();
          // Enable collisions among enemies (but not with player)
          this.physics.add.collider(this.enemiesGroup, this.enemiesGroup);

          // Reset difficulty settings to easy
          this.enemySpawnInterval = 2000; // 2 seconds between spawns
          this.maxEnemies = 6; // Fewer enemies early on

          // Create penguin animations
          this.anims.create({
            key: "walk",
            frames: this.anims.generateFrameNumbers("pudgyPenguin", {
              start: 0,
              end: 30,
            }),
            frameRate: 30,
            repeat: -1,
          });

          this.anims.create({
            key: "idle",
            frames: this.anims.generateFrameNumbers("pudgyPenguinIdle", {
              start: 0,
              end: 19,
            }),
            frameRate: 19,
            repeat: -1,
          });

          // Apply shop upgrades
          this.applyShopUpgrades();

          // Increment run counter
          GameRegistry.totalRuns++;

          // Black background to prevent white showing during screen shake
          this.add.rectangle(200, 300, 400, 600, 0x000000);

          // Background (frozen arena)
          this.add.image(200, 300, "gamebg");

          this.add.image(200, 300, "gamebg2").setAlpha(0.3);

          // Fog of War System
          this.setupFogOfWar();

          // Create player in center
          this.player = this.add.sprite(200, 300, "pudgyPenguinIdle");
          this.physics.add.existing(this.player);
          this.player.setScale(0.5);
          this.player.body.setCollideWorldBounds(true);
          this.player.anims.play("idle", true);
          // Input
          this.cursors = this.input.keyboard.createCursorKeys();
          this.wasd = {
            W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
            A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
            D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
          };

          // Auto-shooting system (no manual input needed)

          // Create health bar above player
          this.createHealthBar();

          this.waveText = this.add.text(10, 50, `Time: 0s`, {
            fontSize: "16px",
            fontFamily: "Fobble",
            color: "#ffff00",
            stroke: "#000000",
            strokeThickness: 3,
          });
          this.waveText.setVisible(false);

          this.scoreText = this.add
            .text(20, 50, `Score: 0`, {
              fontSize: "32px",
              fontFamily: "Fobble",
              color: "#00ff00",
              stroke: "#000000",
              strokeThickness: 3,
            })
            .setDepth(100);

          // Combo display
          this.comboText = this.add
            .text(20, 90, "", {
              fontSize: "24px",
              fontFamily: "Fobble",
              color: "#ff6b35",
              stroke: "#000000",
              strokeThickness: 3,
            })
            .setDepth(100);
          this.comboText.setVisible(false);

          // XP Bar UI
          this.levelText = this.add.text(
            10,
            90,
            `Level: ${this.currentLevel}`,
            {
              fontSize: "16px",
              fontFamily: "Fobble",
              color: "#ff00ff",
              stroke: "#000000",
              strokeThickness: 3,
            }
          );
          this.levelText.setVisible(false);

          // XP Bar background (rounded)
          this.xpBarBg = this.add.graphics();
          this.xpBarBg.fillStyle(0x333333, 0.8);
          this.xpBarBg.lineStyle(2, 0x000000, 1);
          this.xpBarBg.fillRoundedRect(20, 20, 360, 20, 10);
          this.xpBarBg.strokeRoundedRect(20, 20, 360, 20, 10);
          this.xpBarBg.setScrollFactor(0); // Fixed to camera
          this.xpBarBg.setDepth(100);

          // XP Bar fill (rounded)
          this.xpBar = this.add.graphics();
          this.xpBar.fillStyle(0x00ff00, 0.9);
          this.xpBar.fillRoundedRect(20, 20, 20, 20, 10);
          this.xpBar.setScrollFactor(0); // Fixed to camera
          this.xpBar.setDepth(101);

          // Create backpack UI
          this.createBackpackUI();

          // Start continuous spawning
          this.startContinuousSpawning();

          // Create mobile joystick
          this.createMobileJoystick();

          // Start ambient sound loop
          this.ambientSound = this.sound.add("AmbienceFx", {
            loop: true,
            volume: 0.4,
          });
          this.ambientSound.play();

          // Fade in from black
          this.cameras.main.fadeIn(800, 0, 0, 0);
        }

        shutdown() {
          // Stop all sounds when scene is destroyed
          this.sound.stopAll();

          // Clean up specific sound references
          if (this.ambientSound) {
            this.ambientSound.destroy();
          }
          if (this.FightMusic) {
            this.FightMusic.destroy();
          }
          if (this.levelUpMusic) {
            this.levelUpMusic.destroy();
          }
        }

        createMobileJoystick() {
          // Always create joystick (no mobile detection)
          // this.input.addPointer(2); // Add second pointer for multi-touch

          const joystickSize = 60;
          const knobSize = 20;
          const joystickX = 90; // 10px more to the right
          const joystickY = this.cameras.main.height - 90; // 10px more to the top

          // Track joystick input (like keyboard isDown) - binary states
          this.mobileInput = {
            up: false,
            down: false,
            left: false,
            right: false,
          };

          // Joystick properties
          this.joystick = {
            base: null,
            knob: null,
            isActive: false,
            centerX: joystickX,
            centerY: joystickY,
            maxDistance: joystickSize - knobSize - 5,
            activePointer: null,
          };

          // Create joystick base (outer circle) - brand colors
          this.joystick.base = this.add
            .circle(joystickX, joystickY, joystickSize, 0x00142d, 0.4)
            .setDepth(200)
            .setScrollFactor(0)
            .setStrokeStyle(4, 0x477dfd, 0.45)
            .setInteractive({ useHandCursor: false });

          // Create joystick knob (inner circle) - brand colors
          this.joystick.knob = this.add
            .circle(joystickX, joystickY, knobSize, 0x80abff, 0.45)
            .setDepth(201)
            .setScrollFactor(0)
            .setStrokeStyle(3, 0x477dfd, 0.5)
            .setInteractive({ useHandCursor: false });

          // Joystick input handling - base events
          this.joystick.base.on("pointerdown", (pointer) => {
            this.joystick.isActive = true;
            this.joystick.activePointer = pointer;
            this.updateJoystickInput(pointer);
          });

          this.joystick.base.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          this.joystick.base.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });

          // Also handle knob events for better touch response
          this.joystick.knob.on("pointerdown", (pointer) => {
            this.joystick.isActive = true;
            this.joystick.activePointer = pointer;
            this.updateJoystickInput(pointer);
          });

          this.joystick.knob.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          this.joystick.knob.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });

          // Global pointerup to handle finger lifted outside joystick area
          this.input.on("pointerup", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.joystick.isActive = false;
              this.joystick.activePointer = null;
              this.resetJoystickInput();
            }
          });

          // Global pointermove to handle finger movement anywhere on screen
          this.input.on("pointermove", (pointer) => {
            if (
              this.joystick.isActive &&
              this.joystick.activePointer === pointer
            ) {
              this.updateJoystickInput(pointer);
            }
          });
        }

        updateJoystickInput(pointer) {
          const deltaX = pointer.x - this.joystick.centerX;
          const deltaY = pointer.y - this.joystick.centerY;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          // Reset all directions first
          this.mobileInput.up = false;
          this.mobileInput.down = false;
          this.mobileInput.left = false;
          this.mobileInput.right = false;

          // Only set directions if we're far enough from center (like pressing a key)
          if (distance > 15) {
            // Dead zone - must move at least 15 pixels from center
            // Allow diagonal movement by checking each axis independently

            // Horizontal movement
            if (Math.abs(deltaX) > 15) {
              if (deltaX < 0) {
                this.mobileInput.left = true; // Like pressing left arrow key
              } else {
                this.mobileInput.right = true; // Like pressing right arrow key
              }
            }

            // Vertical movement
            if (Math.abs(deltaY) > 15) {
              if (deltaY < 0) {
                this.mobileInput.up = true; // Like pressing up arrow key
              } else {
                this.mobileInput.down = true; // Like pressing down arrow key
              }
            }
          }

          // Update knob position (constrained to joystick area)
          if (distance <= this.joystick.maxDistance) {
            this.joystick.knob.setPosition(pointer.x, pointer.y);
          } else {
            const angle = Math.atan2(deltaY, deltaX);
            const constrainedX =
              this.joystick.centerX +
              Math.cos(angle) * this.joystick.maxDistance;
            const constrainedY =
              this.joystick.centerY +
              Math.sin(angle) * this.joystick.maxDistance;
            this.joystick.knob.setPosition(constrainedX, constrainedY);
          }
        }

        resetJoystickInput() {
          // Reset all directions (like releasing all keys)
          this.mobileInput.up = false;
          this.mobileInput.down = false;
          this.mobileInput.left = false;
          this.mobileInput.right = false;

          // Stop player movement immediately
          if (this.player && this.player.body) {
            this.player.body.setVelocity(0, 0);
          }

          // Smooth return to center
          this.tweens.add({
            targets: this.joystick.knob,
            x: this.joystick.centerX,
            y: this.joystick.centerY,
            duration: 200,
            ease: "Back.easeOut",
          });
        }

        createConfettiEffect() {
          // Create confetti particle texture if it doesn't exist
          if (!this.textures.exists("confettiTexture")) {
            const texture = this.textures.createCanvas("confettiTexture", 8, 8);
            const context = texture.getContext();
            context.fillStyle = "#ffffff";
            context.fillRect(0, 0, 8, 8);
            texture.refresh();
          }

          // Create confetti particles at camera position
          const confetti = this.add.particles(
            this.cameras.main.centerX,
            this.cameras.main.centerY,
            "confettiTexture",
            {
              emitZone: {
                type: "random",
                quantity: 1,
                source: new Phaser.Geom.Rectangle(-200, -300, 700, 1),
              },
              speedY: { min: 200, max: 400 },
              speedX: { min: -150, max: 150 },
              accelerationY: { min: 50, max: 100 },
              lifespan: { min: 2000, max: 3500 },
              scaleX: {
                onUpdate: (particle, key, t) => {
                  return Math.sin((t / 1) * Math.PI * 8);
                },
              },
              blendMode: "ADD",
              rotate: { min: -180, max: 180 },
              frequency: 30,
              quantity: 3,
              tint: [
                0xff6b35, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xf0932b, 0xeb4d4b,
                0x6c5ce7, 0xa29bfe,
              ],
              alpha: { start: 1, end: 0 },
              scale: { start: 0.8, end: 0.2 },
            }
          );

          // Set confetti depth to appear behind level up choices but above background
          confetti.setDepth(1001);

          // Stop emitting confetti after 1 second
          this.time.delayedCall(1000, () => {
            if (confetti) {
              confetti.stop();
            }
          });

          // Destroy confetti emitter after all particles have fallen off-screen
          this.time.delayedCall(3000, () => {
            if (confetti) {
              confetti.destroy();
            }
          });
        }

        startContinuousSpawning() {
          // Spawn initial enemies

          // Set lastEnemySpawn to current time to prevent immediate additional spawning
          this.lastEnemySpawn = this.time.now;
        }

        updateContinuousSpawning(time) {
          // Use per-run elapsed time instead of global engine time
          const elapsed = this.time.now - (this.runStartTime || 0);
          this.gameTime = elapsed;
          this.waveText.setText(`Time: ${Math.floor(elapsed / 1000)}s`);

          // Scale difficulty based on per-run elapsed time
          const timeInSeconds = Math.floor(elapsed / 1000);

          // Faster spawn rate over time
          if (timeInSeconds >= 360) {
            this.maxEnemies = 30; // More enemies on screen
          } else if (timeInSeconds >= 300) {
            this.enemySpawnInterval = 500; // 1 second between spawns
            this.maxEnemies = 25; // More enemies on screen
          } else if (timeInSeconds >= 240) {
            this.maxEnemies = 18; // More enemies on screen
          } else if (timeInSeconds >= 180) {
            this.enemySpawnInterval = 1000; // 1 second between spawns
            this.maxEnemies = 16; // More enemies on screen
          } else if (timeInSeconds >= 120) {
            this.enemySpawnInterval = 1500; // 1.5 seconds between spawns
            this.maxEnemies = 14; // More enemies on screen
          } else if (timeInSeconds >= 60) {
            this.enemySpawnInterval = 1800; // 1.8 seconds between spawns
            this.maxEnemies = 12; // Default max enemies
          } else {
            this.enemySpawnInterval = 2000; // 2 seconds between spawns
            this.maxEnemies = 6; // Fewer enemies early on
          }

          // Spawn enemies if conditions are met
          if (
            time - this.lastEnemySpawn > this.enemySpawnInterval &&
            this.enemies.length < this.maxEnemies
          ) {
            this.spawnEnemy();
            this.lastEnemySpawn = time;
          }
        }

        spawnEnemy() {
          // Determine enemy type based on time
          const enemyType = this.getEnemyTypeForLevel();

          // Spawn at edges of screen
          const edge = Phaser.Math.Between(0, 3);
          let x, y;

          switch (edge) {
            case 0: // Top
              x = Phaser.Math.Between(50, 350);
              y = 0;
              break;
            case 1: // Right
              x = 400;
              y = Phaser.Math.Between(50, 550);
              break;
            case 2: // Bottom
              x = Phaser.Math.Between(50, 350);
              y = 600;
              break;
            case 3: // Left
              x = 0;
              y = Phaser.Math.Between(50, 550);
              break;
          }

          this.createEnemy(enemyType, x, y);
        }

        getEnemyTypeForLevel() {
          // Introduce enemy types gradually by time (not level)
          const timeInSeconds = Math.floor(this.gameTime / 1000);

          if (timeInSeconds >= 180) {
            // 120+ seconds: All types available
            const types = ["small", "big", "swarm", "boss", "boss2"];
            return Phaser.Utils.Array.GetRandom(types);
          } else if (timeInSeconds >= 120) {
            // 60+ seconds: All types available
            const types = ["small", "big", "swarm", "boss"];
            return Phaser.Utils.Array.GetRandom(types);
          } else if (timeInSeconds >= 60) {
            // 30-59 seconds: Small, Big, Swarm
            const types = ["small", "big", "swarm"];
            return Phaser.Utils.Array.GetRandom(types);
          } else if (timeInSeconds >= 30) {
            // 15-29 seconds: Small, Big
            const types = ["small", "big"];
            return Phaser.Utils.Array.GetRandom(types);
          } else {
            // 0-14 seconds: Only small enemies
            return "small";
          }
        }

        createEnemy(type, x, y, isSwarmSpawn = false) {
          let enemy, health, speed, scale, spriteKey, animKey;

          switch (type) {
            case "small":
              // Small enemy - use enemy1 sprite
              spriteKey = "enemy1";
              animKey = "enemy1Walk";
              scale = 0.3;
              health = 30;
              speed = 60;
              break;

            case "big":
              // Bigger enemy - use enemy3 sprite
              spriteKey = "enemy3";
              animKey = "enemy3Walk";
              scale = 0.4;
              health = 40;
              speed = 40;
              break;

            case "swarm":
              // Swarm type - use enemy2 sprite (flying)
              spriteKey = "enemy2";
              animKey = "enemy2Walk";
              scale = 0.25;
              health = 15;
              speed = 70;
              break;

            case "boss":
              // Boss type - use enemy4 sprite
              spriteKey = "enemy4";
              animKey = "enemy4Walk";
              scale = 0.5;
              health = 70;
              speed = 30;
              break;

            case "boss2":
              // Boss type - use enemy5 sprite
              spriteKey = "enemy5";
              animKey = "enemy5Walk";
              scale = 0.6;
              health = 150;
              speed = 60;
              break;
          }

          enemy = this.add.sprite(x, y, spriteKey);
          enemy.setScale(scale);
          enemy.play(animKey);
          this.physics.add.existing(enemy);

          // Add enemy to group for collisions
          this.enemiesGroup.add(enemy);
          enemy.body.setImmovable(false);
          enemy.body.setBounce(0.2);
          enemy.setDepth(2);

          this.enemies.push({
            sprite: enemy,
            type: type,
            health: health,
            maxHealth: health,
            speed: speed,
            lastShot: 0,
            lastCharge: 0, // For boss charging
            chargeCooldown: 3000, // 3 seconds between charges
            spriteKey: spriteKey,
            animKey: animKey,
          });

          // Special behavior for swarm enemies - spawn multiple (only if not already spawning swarm)
          if (type === "swarm" && !isSwarmSpawn) {
            // Spawn 2-3 additional swarm enemies nearby
            const swarmCount = Phaser.Math.Between(2, 3);
            for (let i = 0; i < swarmCount; i++) {
              const offsetX = x + Phaser.Math.Between(-30, 30);
              const offsetY = y + Phaser.Math.Between(-30, 30);
              this.createEnemy("swarm", offsetX, offsetY, true); // Pass true to prevent recursion
            }
          }
        }

        autoShoot(time) {
          if (
            time - this.lastShot < this.playerFireRate ||
            !this.player ||
            this.enemies.length === 0
          )
            return;

          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDistance = Infinity;

          for (const enemy of this.enemies) {
            const distance = Phaser.Math.Distance.Between(
              this.player.x,
              this.player.y,
              enemy.sprite.x,
              enemy.sprite.y
            );

            if (distance < nearestDistance) {
              nearestDistance = distance;
              nearestEnemy = enemy;
            }
          }

          if (!nearestEnemy) return;

          this.lastShot = time;

          // Calculate base damage with critical hit chance
          let damage = this.playerDamage;
          const isCrit = Math.random() < this.critChance;
          if (isCrit) {
            damage *= 2;
          }

          // Determine number of bullets to shoot
          const bulletCount = this.multiShot ? 2 : 1;
          const angleSpread = this.multiShot ? 0.2 : 0; // Spread for multi-shot

          for (let i = 0; i < bulletCount; i++) {
            const bullet = this.add
              .sprite(
                this.player.x,
                this.player.y,
                "snowball",
                GameRegistry.upgrades.burningBullets
                  ? 0xff4500
                  : isCrit
                  ? 0xff00ff
                  : 0x00ffff // Orange for burning, purple for crits, cyan for normal
              )
              .setScale(0.13);

            this.physics.add.existing(bullet);

            bullet.play("snowballMovement");
            this.sound.play("ShootFx", {
              volume: 0.01,
              detune: Phaser.Math.Between(-50, 50),
            });
            // Add damage and effect properties to bullet
            bullet.damage = damage;
            bullet.isCrit = isCrit;
            bullet.burning = GameRegistry.upgrades.burningBullets;
            bullet.frost = GameRegistry.upgrades.frostBullets;

            const angle = Phaser.Math.Angle.Between(
              this.player.x,
              this.player.y,
              nearestEnemy.sprite.x,
              nearestEnemy.sprite.y
            );

            // Add spread for multi-shot
            const finalAngle = angle + (i - 1) * angleSpread;

            const velocity = new Phaser.Math.Vector2(
              Math.cos(finalAngle) * 400,
              Math.sin(finalAngle) * 400
            );

            bullet.body.setVelocity(velocity.x, velocity.y);

            this.bullets.push({
              sprite: bullet,
              velocity: velocity,
              isPlayerBullet: true,
              startX: this.player.x,
              startY: this.player.y,
              maxDistance: this.getBulletRange(),
            });
          }
        }

        update(time, delta) {
          // Check if game is paused (during upgrade selection)
          if (this.physics.world.isPaused) {
            return; // Don't update anything if game is paused
          }

          this.updatePlayer(delta);
          this.updateEnemies(time, delta);
          this.updateBullets();
          this.updateEmberPickups();
          this.checkCollisions();
          this.updateContinuousSpawning(time);
          this.autoShoot(time);
          this.updateFogOfWar();
          this.updateBlizzard(time);
          this.updatePenguinAllies(delta);
          this.updateDepths();
        }

        spawnEmberPickup(x, y) {
          // Create glowing ember circle
          const ember = this.add.circle(x, y, 4, 0xf73718);
          ember.setStrokeStyle(2, 0xffaa00);
          this.physics.add.existing(ember);

          // Add slight bounce/wobble effect
          this.tweens.add({
            targets: ember,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 400,
            yoyo: true,
            repeat: -1,
          });

          ember.setDepth(0);

          this.emberPickups.push(ember);
        }

        createHitParticles(x, y, isCrit = false) {
          // Create particle burst on hit
          const particleCount = isCrit ? 8 : 5;
          const colors = isCrit
            ? [0xff00ff, 0xffffff, 0xff69b4]
            : [0x00ffff, 0xffffff, 0x87ceeb];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x,
              y,
              3,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.8);

            // Random direction and speed
            const angle =
              (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
            const speed = Phaser.Math.Between(50, 150);

            this.physics.add.existing(particle);
            particle.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 300,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        emitFireNova(x, y) {
          const radius = 120;
          const damage = 2;
          this.sound.play("FireSpellFx", { volume: 0.6 });
          // Visual: two quick expanding circles with orange tint
          const ring1 = this.add.circle(x, y, 10, 0xff6b35, 0.3).setDepth(110);
          const ring2 = this.add.circle(x, y, 6, 0xffa500, 0.25).setDepth(110);
          this.tweens.add({
            targets: ring1,
            radius: radius * 1.2,
            alpha: 0,
            duration: 300,
            onComplete: () => ring1.destroy(),
          });
          this.tweens.add({
            targets: ring2,
            radius: radius * 0.9,
            alpha: 0,
            duration: 320,
            onComplete: () => ring2.destroy(),
          });

          // Damage nearby enemies
          for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            const d = Phaser.Math.Distance.Between(
              x,
              y,
              enemy.sprite.x,
              enemy.sprite.y
            );
            if (d <= radius) {
              enemy.health -= damage;
              this.createBurningHitParticles(enemy.sprite.x, enemy.sprite.y);
              if (enemy.health <= 0) {
                this.spawnEmberPickup(enemy.sprite.x, enemy.sprite.y);
                this.playEnemyExplosion(enemy.sprite.x, enemy.sprite.y);
                enemy.sprite.destroy();
                this.enemies.splice(i, 1);
              }
            }
          }
        }

        playEnemyExplosion(x, y) {
          const explosion = this.add.sprite(x, y, "explosion1");
          explosion.setDepth(99);
          explosion.setScale(0.6);
          explosion.play("enemyExplosion");
          explosion.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
            explosion.destroy();
          });

          const explosion2 = this.add.sprite(x, y, "explosion2");
          explosion2.setDepth(99);
          explosion2.setScale(0.6);
          explosion2.play("enemyExplosion2");
          explosion2.once(Phaser.Animations.Events.ANIMATION_COMPLETE, () => {
            explosion2.destroy();
          });
        }

        createBlizzardEffect() {
          // Create blizzard area indicator
          const blizzardArea = this.add.circle(
            this.player.x,
            this.player.y,
            80,
            0x00aaff
          );
          blizzardArea.setAlpha(0.3);
          blizzardArea.setStrokeStyle(3, 0x00ffff, 0.6);
          this.sound.play("WhooshFx", { volume: 0.6 });
          // Animate the blizzard area
          this.tweens.add({
            targets: blizzardArea,
            alpha: 0,
            scaleX: 1.5,
            scaleY: 1.5,
            duration: 1000,
            onComplete: () => {
              blizzardArea.destroy();
            },
          });

          // Create snow particles around the player
          for (let i = 0; i < 15; i++) {
            const snow = this.add.circle(
              this.player.x + Phaser.Math.Between(-80, 80),
              this.player.y + Phaser.Math.Between(-80, 80),
              2,
              0xffffff
            );
            snow.setAlpha(0.8);

            // Random movement
            const angle = Math.random() * Math.PI * 2;
            const speed = Phaser.Math.Between(30, 80);

            this.physics.add.existing(snow);
            snow.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: snow,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 1000,
              onComplete: () => {
                snow.destroy();
              },
            });
          }
        }

        createBlizzardHitParticles(x, y) {
          // Create ice/snow particles for blizzard hits
          const particleCount = 6;
          const colors = [0x00ffff, 0xffffff, 0x87ceeb, 0xb0e0e6];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x,
              y,
              2,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.9);

            // Random direction and speed
            const angle = Math.random() * Math.PI * 2;
            const speed = Phaser.Math.Between(40, 120);

            this.physics.add.existing(particle);
            particle.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 400,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        createFireHitParticles(x, y) {
          // Create fire particles for fire totem hits
          const particleCount = 4;
          const colors = [0xff4500, 0xff0000, 0xffa500, 0xffff00];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x,
              y,
              3,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.9);

            // Random direction and speed
            const angle = Math.random() * Math.PI * 2;
            const speed = Phaser.Math.Between(30, 80);

            this.physics.add.existing(particle);
            particle.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 300,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        createBurningHitParticles(x, y) {
          // Create fire particles when burning bullets hit
          const particleCount = 5;
          const colors = [0xff4500, 0xff0000, 0xffa500, 0xffff00, 0xff6347];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x,
              y,
              2,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.8);

            // Random direction and speed
            const angle = Math.random() * Math.PI * 2;
            const speed = Phaser.Math.Between(40, 100);

            this.physics.add.existing(particle);
            particle.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 400,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        createBurningDamageParticles(x, y) {
          // Create small fire particles for ongoing burning damage
          const particleCount = 3;
          const colors = [0xff4500, 0xff0000, 0xffa500];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x + Phaser.Math.Between(-10, 10),
              y + Phaser.Math.Between(-10, 10),
              1,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.7);

            // Random direction and speed
            const angle = Math.random() * Math.PI * 2;
            const speed = Phaser.Math.Between(20, 60);

            this.physics.add.existing(particle);
            particle.body.setVelocity(
              Math.cos(angle) * speed,
              Math.sin(angle) * speed
            );

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 500,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        updateEmberPickups() {
          if (!this.player) return;

          for (let i = this.emberPickups.length - 1; i >= 0; i--) {
            const ember = this.emberPickups[i];

            // Check if player is near ember
            const distance = Phaser.Math.Distance.Between(
              this.player.x,
              this.player.y,
              ember.x,
              ember.y
            );

            // Ember magnet increases collection range
            const collectionRange = this.emberMagnet ? 60 : 25;

            if (distance < collectionRange) {
              // Collect ember - add to both current run and total
              this.emberCount += 5;
              GameRegistry.embers += 5;
              this.sound.play("CollectPointsFx", { volume: 0.4 });
              // Update backpack display
              this.updateBackpackDisplay();

              // Gain XP
              this.gainXP(10);

              // Apply fish feast effect
              if (GameRegistry.upgrades.fishFeast) {
                if (Math.random() < 0.1) {
                  this.playerHealth = Math.min(
                    this.playerMaxHealth,
                    this.playerHealth + 1
                  );
                }
                this.updateHealthBar();
              }

              // Save immediately after collection
              gameData.saveGameState();

              // Visual feedback
              this.tweens.add({
                targets: ember,
                scale: 0,
                alpha: 0,
                duration: 150,
                onComplete: () => ember.destroy(),
              });

              this.emberPickups.splice(i, 1);
            } else if (this.emberMagnet && distance < 110) {
              // Attract ember towards player
              const angle = Phaser.Math.Angle.Between(
                ember.x,
                ember.y,
                this.player.x,
                this.player.y
              );

              const attractionSpeed = 150;
              ember.body.setVelocity(
                Math.cos(angle) * attractionSpeed,
                Math.sin(angle) * attractionSpeed
              );
            }
          }
        }

        gainXP(amount) {
          // Safety check - prevent XP gain if game is paused (during upgrade selection)
          if (this.physics.world.isPaused) {
            return;
          }

          this.currentXP += amount;
          this.updateXPBar();

          // Check for level up
          if (this.currentXP >= this.xpToNextLevel) {
            this.levelUp();
          }
        }

        updateXPBar() {
          if (!this.xpBar || !this.levelText) return;

          const progress = this.currentXP / this.xpToNextLevel;
          let barWidth = 360 * progress;
          if (barWidth < 20) {
            barWidth = 20;
          }

          // Clear and redraw the XP bar fill with new width
          this.xpBar.clear();
          this.xpBar.fillStyle(0x00ff00, 0.9);
          this.xpBar.fillRoundedRect(20, 20, barWidth, 20, 10);

          this.levelText.setText(`Level: ${this.currentLevel}`);
        }

        levelUp() {
          // Safety check - prevent multiple level-ups
          if (this.physics.world.isPaused) {
            return;
          }

          this.currentLevel++;
          this.currentXP -= this.xpToNextLevel;
          this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); // Increase XP requirement

          this.updateXPBar();
          this.showUpgradeChoices();
        }

        showUpgradeChoices() {
          // Stop fight music and play level up music
          if (this.FightMusic) {
            this.FightMusic.stop();
          }
          this.sound.play("NotifyFx", { volume: 0.5 });
          this.levelUpMusic = this.sound.add("LevelUpMusic", {
            loop: true,
            volume: 0.5,
          });
          this.levelUpMusic.play();

          // Create confetti effect for level up celebration
          this.createConfettiEffect();

          // Build upgrade pool with availability rules
          const allUpgrades = [
            {
              name: "Damage Boost",
              description: "Increased Damage",
              effect: () => {
                this.playerDamage += 10;
              },
              available: () => true,
            },
            {
              name: "Fire Rate",
              description: "Faster Shooting",
              effect: () => {
                this.playerFireRate = Math.max(50, this.playerFireRate - 10);
              },
              available: () => true,
            },
            {
              name: "Health Boost",
              description: "Max Health Increase",
              effect: () => {
                this.playerMaxHealth += 20;
                this.playerHealth = Math.min(
                  this.playerMaxHealth,
                  this.playerHealth + 50
                );
                this.updateHealthBar();
              },
              available: () => true,
            },
            {
              name: "Speed Boost",
              description: "Increased Movement Speed",
              effect: () => {
                this.playerSpeed += 10;
              },
              available: () => true,
            },
            {
              name: "Health Regen",
              description: "Full Health",
              effect: () => {
                this.playerHealth = this.playerMaxHealth;
                this.updateHealthBar();
              },
              available: () => true,
            },
            {
              name: "Critical Hit",
              description: "Chance for 2x damage",
              effect: () => {
                this.critChance = 0.1;
              },
              available: () => !this.critChance || this.critChance <= 0,
            },
            {
              name: "Multi Shot",
              description: "Shoot 2 bullets at once",
              effect: () => {
                this.multiShot = true;
              },
              available: () => !this.multiShot,
            },
            {
              name: "Score Multiplier",
              description: "Increased Score Bonus",
              effect: () => {
                this.scoreMultiplier += 0.5;
              },
              available: () => true,
            },
            {
              name: "Expanded Vision",
              description: "Increased Fog of War radius",
              effect: () => {
                this.fowRadiusMultiplier += 0.1;
                this.updateFowRadius();
              },
              available: () => true,
            },
            {
              name: "Ember Magnet",
              description: "Attracts nearby embers",
              effect: () => {
                this.emberMagnet = true;
              },
              available: () => !this.emberMagnet,
            },
          ];

          const availableUpgrades = allUpgrades.filter((u) => u.available());

          // If no upgrades are available, skip showing the screen
          if (availableUpgrades.length === 0) {
            return;
          }

          // Pause the game completely now that we know there are choices
          this.physics.pause();

          // Stop player movement
          if (this.player && this.player.body) {
            this.player.body.setVelocity(0);
          }

          // Stop all enemy movement
          this.enemies.forEach((enemy) => {
            if (enemy.body) {
              enemy.body.setVelocity(0);
            }
          });

          // Stop all bullets
          this.bullets.forEach((bullet) => {
            if (bullet.body) {
              bullet.body.setVelocity(0);
            }
          });

          // Pick up to 3 random upgrades from the available pool
          const chosenUpgrades = Phaser.Utils.Array.Shuffle([
            ...availableUpgrades,
          ]).slice(0, 3);

          // Create UI overlay (rounded)
          const overlay = this.add.graphics();
          overlay.fillStyle(0x000000, 0.8);

          overlay.fillRect(0, 0, 400, 600);
          overlay.setScrollFactor(0);
          overlay.setDepth(1000);

          const title = this.add.text(200, 85, "LEVEL UP!", {
            fontSize: "42px",
            fontFamily: "Fobble",
            color: "#ff6b9d",
            stroke: "#000000",
            strokeThickness: 4,
          });
          title.setOrigin(0.5);
          title.setScrollFactor(0);
          title.setDepth(1001);

          // Store all UI elements for cleanup
          const uiElements = [overlay, title];

          // Create upgrade buttons
          chosenUpgrades.forEach((upgrade, index) => {
            const y = 175 + index * 100;

            // Create rounded button using graphics
            const button = this.add.graphics();
            button.fillStyle(0x4a5568, 0.9); // Soft gray background
            button.lineStyle(4, 0x68d391, 1); // Green border
            button.fillRoundedRect(50, y - 40, 300, 80, 20); // Rounded rectangle
            button.strokeRoundedRect(50, y - 40, 300, 80, 20);
            button.setScrollFactor(0);
            button.setDepth(1001);
            button.setInteractive(
              new Phaser.Geom.Rectangle(50, y - 40, 300, 80),
              Phaser.Geom.Rectangle.Contains
            );

            // Hover effects
            button.on("pointerover", () => {
              button.clear();
              button.fillStyle(0x5a6578, 0.9); // Slightly lighter gray
              button.lineStyle(4, 0x81e6d9, 1); // Cyan border
              button.fillRoundedRect(50, y - 40, 300, 80, 20);
              button.strokeRoundedRect(50, y - 40, 300, 80, 20);
            });

            button.on("pointerout", () => {
              button.clear();
              button.fillStyle(0x4a5568, 0.9); // Back to original gray
              button.lineStyle(4, 0x68d391, 1); // Back to green border
              button.fillRoundedRect(50, y - 40, 300, 80, 20);
              button.strokeRoundedRect(50, y - 40, 300, 80, 20);
            });

            const nameText = this.add.text(200, y - 15, upgrade.name, {
              fontSize: "24px",
              fontFamily: "Fobble",
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 3,
            });
            nameText.setOrigin(0.5);
            nameText.setScrollFactor(0);
            nameText.setDepth(1002);

            const descText = this.add.text(200, y + 10, upgrade.description, {
              fontSize: "18px",
              fontFamily: "Fobble",
              color: "#e2e8f0",
              stroke: "#000000",
              strokeThickness: 2,
            });
            descText.setOrigin(0.5);
            descText.setScrollFactor(0);
            descText.setDepth(1002);

            // Add to cleanup list
            uiElements.push(button, nameText, descText);

            button.on("pointerdown", () => {
              this.sound.play("LevelUpFx", { volume: 0.4 });
              this.sound.play("WhooshFx", { volume: 0.7 });
              if (this.levelUpMusic) {
                this.levelUpMusic.stop();
                this.levelUpMusic.destroy();
              }
              if (this.FightMusic) {
                this.FightMusic.play();
              }

              upgrade.effect();

              // Blast nearby enemies away to give breathing room
              this.triggerLevelUpBlast();

              // Clean up all UI elements
              uiElements.forEach((element) => {
                if (element && element.destroy) {
                  element.destroy();
                }
              });

              this.physics.resume();
            });
          });
        }

        createBackpackUI() {
          // Backpack sprite in bottom right
          this.backpackSprite = this.add.image(330, 540, "backpack");
          this.backpackSprite.setScale(1);
          this.backpackSprite.setScrollFactor(0); // Fixed to camera
          this.backpackSprite.setDepth(100);
          this.backpackSprite.setAlpha(0.5);

          this.backpackSprite2 = this.add.image(330, 540, "backpack2");
          this.backpackSprite2.setScale(1);
          this.backpackSprite2.setScrollFactor(0); // Fixed to camera
          this.backpackSprite2.setDepth(105);

          // Ember count text on backpack
          this.backpackEmberText = this.add.text(
            330,
            570,
            `${GameRegistry.embers}`,
            {
              fontSize: "20px",
              fontFamily: "Fobble",
              color: "#ff8b8b",
              stroke: "#000000",
              strokeThickness: 3,
            }
          );
          this.backpackEmberText.setOrigin(0.5);
          this.backpackEmberText.setScrollFactor(0); // Fixed to camera
          this.backpackEmberText.setDepth(106);

          // Create fire sprites on backpack
          this.createBackpackFire();
        }

        createBackpackFire() {
          // Main fire sprite on backpack
          this.backpackFire = this.add.sprite(330, 530, "shopFire");
          this.backpackFire.setScale(0.3); // Start small
          this.backpackFire.setScrollFactor(0); // Fixed to camera
          this.backpackFire.setDepth(102);
          this.backpackFire.setAlpha(0.6);

          // Secondary fire sprite on backpack
          this.backpackFire2 = this.add.sprite(330, 530, "shopFire2");
          this.backpackFire2.setScale(0.25); // Start small
          this.backpackFire2.setScrollFactor(0); // Fixed to camera
          this.backpackFire2.setDepth(103);
          this.backpackFire2.setAlpha(0.5);

          // Play fire animations
          this.backpackFire.play("fireIgnite", true);
          this.backpackFire2.play("fireIgnite2", true);

          // Update fire scale based on ember count
          this.updateBackpackFire();
        }

        updateBackpackFire() {
          if (!this.backpackFire || !this.backpackFire2) return;

          const emberCount = GameRegistry.embers;
          const intensity = Math.min(emberCount / 200, 1); // Scale from 0-1 based on embers (0-200)

          // Calculate scale based on ember count
          const minScale = 0.01;
          const maxScale = 0.35;
          const scale = minScale + intensity * (maxScale - minScale);

          // Update fire scales
          this.backpackFire.setScale(scale);
          this.backpackFire2.setScale(scale * 0.8); // Slightly smaller than main fire

          // Update alpha based on intensity
          this.backpackFire.setAlpha(0.6 + intensity * 0.4); // 0.6 to 1.0
          this.backpackFire2.setAlpha(0.5 + intensity * 0.3); // 0.5 to 0.8
        }

        updateBackpackDisplay() {
          if (!this.backpackEmberText) return;

          // Update ember count text
          this.backpackEmberText.setText(`${GameRegistry.embers}`);

          // Update fire intensity
          this.updateBackpackFire();
        }

        setupFogOfWar() {
          // Create a full-screen render texture to act as the fog overlay
          this.rt = this.make.renderTexture({
            x: 200,
            y: 300,
            width: 450,
            height: 650,
            add: true,
          });
          this.rt.fill(0x000000, 0.9); // Mostly opaque black
          this.rt.setDepth(100);

          // Create the vision image (soft-edged black circle) without adding to the display list
          const vision = this.make.image({
            x: 200,
            y: 300,
            key: "fow",
            add: false,
          });

          this.vision = vision;
          this.vision.setScale(0.9).setDepth(5);

          // Create an inverted bitmap mask using the vision image and apply to the render texture
          this.fogMask = new Phaser.Display.Masks.BitmapMask(this, vision);
          this.fogMask.invertAlpha = true;
          this.rt.mask = this.fogMask;

          // Create atmospheric snow particles
          this.createSnowParticles();
        }

        createSnowParticles() {
          // Create snow texture (white circle) - same as hub scene
          const snowTexture = this.add.graphics();
          snowTexture.fillStyle(0xffffff);
          snowTexture.fillCircle(4, 4, 4);
          snowTexture.generateTexture("snowCircle", 8, 8);

          // Create snow particle emitter
          this.snowParticles = this.add.particles(0, 0, "snowCircle", {
            x: { min: -50, max: 450 },
            y: { min: -50, max: 600 },
            speedX: { min: 6, max: 20 },
            speedY: { min: 10, max: 80 },
            scale: { start: 0.3, end: 0.1 },
            alpha: { start: 0.8, end: 0.2 },
            lifespan: 8000,
            frequency: 50,
            quantity: 1,
          });

          // Set snow particles depth (behind fog but above background)
          this.snowParticles.setDepth(150);

          // Apply the same fog mask to snow particles
          this.snowParticles.mask = this.fogMask;
        }

        updateFogOfWar() {
          if (this.vision && this.player) {
            this.vision.x = this.player.x;
            this.vision.y = this.player.y;
          }
        }

        updateFowRadius() {
          if (this.vision) {
            this.vision.setScale(1 * this.fowRadiusMultiplier);
          }
        }

        getBulletRange() {
          // Base vision radius approximated from vision sprite scale
          // Original vision scale ~1 maps well to ~120px radius
          const baseRadius = 120;
          return baseRadius * this.fowRadiusMultiplier;
        }

        triggerLevelUpBlast() {
          if (!this.player) return;

          const x = this.player.x;
          const y = this.player.y;
          const radius = 120; // Blast radius

          // Visual: quick expanding ring
          const ring = this.add.circle(x, y, 12, 0x81e6d9, 0.6).setDepth(90);
          this.tweens.add({
            targets: ring,
            radius: radius * 2,
            alpha: 0,
            duration: 600,
            onComplete: () => ring.destroy(),
          });

          // Apply push to enemies in radius (reusing hitback fields)
          for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            const d = Phaser.Math.Distance.Between(
              x,
              y,
              enemy.sprite.x,
              enemy.sprite.y
            );
            if (d <= radius) {
              const angle = Phaser.Math.Angle.Between(
                x,
                y,
                enemy.sprite.x,
                enemy.sprite.y
              );
              // Strength scales slightly by proximity
              const strengthBase = 520;
              const falloff = 0.5 + 0.5 * (1 - d / radius); // 0.5..1.0
              const hitbackX = Math.cos(angle) * strengthBase * falloff;
              const hitbackY = Math.sin(angle) * strengthBase * falloff;
              enemy.hitbackX = hitbackX;
              enemy.hitbackY = hitbackY;
              enemy.hitbackTime = this.time.now;
              enemy.hitbackDuration = 600;
            }
          }
        }

        applyShopUpgrades() {
          // Set base stats
          this.playerMaxHealth = 100;
          this.playerHealth = this.playerMaxHealth;
          this.playerSpeed = 100;

          // Apply Ember Efficiency
          if (GameRegistry.upgrades.emberEfficiency) {
            GameRegistry.embers += 50;
          }

          // Apply Waddle Mastery
          if (GameRegistry.upgrades.waddleMastery) {
            this.playerSpeed *= 1.1;
          }

          // Fire Regeneration is passive - no setup needed

          // Apply Pack Leader
          if (GameRegistry.upgrades.packLeader) {
            this.createPenguinAllies();
          }
        }

        createHealParticles(x, y) {
          // Create small green particles for healing
          const particleCount = 3;
          const colors = [0x00ff00, 0x90ee90, 0x32cd32];

          for (let i = 0; i < particleCount; i++) {
            const particle = this.add.circle(
              x + Phaser.Math.Between(-10, 10),
              y + Phaser.Math.Between(-10, 10),
              2,
              colors[Math.floor(Math.random() * colors.length)]
            );
            particle.setAlpha(0.8);

            // Move upward
            this.physics.add.existing(particle);
            particle.body.setVelocity(0, -50);

            // Fade out and destroy
            this.tweens.add({
              targets: particle,
              alpha: 0,
              scaleX: 0,
              scaleY: 0,
              duration: 500,
              onComplete: () => {
                particle.destroy();
              },
            });
          }
        }

        createPenguinAllies() {
          // Create just one penguin ally
          const ally = this.add.sprite(150, 250, "pudgyPenguinIdle");
          ally.setScale(0.4);
          this.physics.add.existing(ally);
          ally.body.setCollideWorldBounds(true);
          ally.setDepth(10);
          this.penguinAllies.push(ally);
        }

        updateBlizzard(time) {
          if (!GameRegistry.upgrades.blizzard) return;

          // Blizzard cooldown
          if (this.blizzardCooldown > 0) {
            this.blizzardCooldown -= 16; // Assuming 60fps
            return;
          }

          // Activate blizzard every 3 seconds
          if (time - this.lastBlizzardTime >= 5000) {
            this.lastBlizzardTime = time;
            this.blizzardCooldown = 1000; // 1 second duration

            // Create blizzard visual effect
            this.createBlizzardEffect();

            // Damage all enemies within 80px
            this.enemies.forEach((enemy) => {
              const distance = Phaser.Math.Distance.Between(
                this.player.x,
                this.player.y,
                enemy.sprite.x,
                enemy.sprite.y
              );

              if (distance < 80) {
                enemy.health -= 5;

                // Create blizzard hit particles
                this.createBlizzardHitParticles(enemy.sprite.x, enemy.sprite.y);

                if (enemy.health <= 0) {
                  this.spawnEmberPickup(enemy.sprite.x, enemy.sprite.y);
                  this.playEnemyExplosion(enemy.sprite.x, enemy.sprite.y);
                  enemy.sprite.destroy();
                  this.enemies.splice(this.enemies.indexOf(enemy), 1);
                }
              }
            });
          }
        }

        updatePenguinAllies(delta) {
          if (!this.penguinAllies.length) return;

          this.penguinAllies.forEach((ally) => {
            // Find closest ember; if none, follow player
            let closestEmber = null;
            let closestDist = Infinity;

            for (let i = this.emberPickups.length - 1; i >= 0; i--) {
              const ember = this.emberPickups[i];
              const d = Phaser.Math.Distance.Between(
                ally.x,
                ally.y,
                ember.x,
                ember.y
              );
              if (d < closestDist) {
                closestDist = d;
                closestEmber = ember;
              }
            }

            const targetX = closestEmber ? closestEmber.x : this.player.x;
            const targetY = closestEmber ? closestEmber.y : this.player.y;

            const angle = Phaser.Math.Angle.Between(
              ally.x,
              ally.y,
              targetX,
              targetY
            );
            const speed = 70;
            const velocityX = Math.cos(angle) * speed;
            const velocityY = Math.sin(angle) * speed;

            ally.body.setVelocity(velocityX, velocityY);
            this.updateSpriteDirection(ally, -velocityX);

            // If close enough to an ember, collect it for the player
            if (closestEmber && closestDist < 20) {
              // Collect ember - add to both current run and total
              this.emberCount += 5;
              GameRegistry.embers += 5;
              this.sound.play("CollectPointsFx", { volume: 0.4 });
              this.updateBackpackDisplay();
              this.gainXP(10);

              // Apply fish feast effect (same as player collection)
              if (GameRegistry.upgrades.fishFeast) {
                if (Math.random() < 0.1) {
                  this.playerHealth = Math.min(
                    this.playerMaxHealth,
                    this.playerHealth + 1
                  );
                }
                this.updateHealthBar();
              }

              gameData.saveGameState();

              // Visual feedback and cleanup
              this.tweens.add({
                targets: closestEmber,
                scale: 0,
                alpha: 0,
                duration: 150,
                onComplete: () => closestEmber.destroy(),
              });

              const idx = this.emberPickups.indexOf(closestEmber);
              if (idx !== -1) this.emberPickups.splice(idx, 1);
            }
          });
        }

        updateDepths() {
          // Update player and enemy depths based on Y positions
          if (!this.player) return;

          const playerY = this.player.y;
          const newPlayerDepth = 10 + (playerY / 600) * 40;

          // Only update player depth if it changed significantly (performance optimization)
          if (
            !this.lastPlayerDepth ||
            Math.abs(newPlayerDepth - this.lastPlayerDepth) > 2
          ) {
            this.player.setDepth(newPlayerDepth);
            this.lastPlayerDepth = newPlayerDepth;
          }

          // Update enemy depths based on Y positions (scale to 10-50 range)
          // Only update every few frames to improve performance
          if (!this.depthUpdateCounter) this.depthUpdateCounter = 0;
          this.depthUpdateCounter++;

          if (this.depthUpdateCounter % 3 === 0) {
            // Update every 3rd frame
            this.enemies.forEach((enemy) => {
              if (enemy.sprite && enemy.sprite.active) {
                const newDepth = 10 + (enemy.sprite.y / 600) * 40;
                if (
                  !enemy.lastDepth ||
                  Math.abs(newDepth - enemy.lastDepth) > 2
                ) {
                  enemy.sprite.setDepth(newDepth);
                  enemy.lastDepth = newDepth;
                }
              }
            });

            // Update penguin allies depths (scale to 10-50 range)
            this.penguinAllies.forEach((ally) => {
              if (ally.sprite && ally.sprite.active) {
                const newDepth = 10 + (ally.sprite.y / 600) * 40;
                if (
                  !ally.lastDepth ||
                  Math.abs(newDepth - ally.lastDepth) > 2
                ) {
                  ally.sprite.setDepth(newDepth);
                  ally.lastDepth = newDepth;
                }
              }
            });
          }
        }

        updateCombo() {
          const currentTime = this.time.now;

          // Check if combo should continue or reset
          if (currentTime - this.lastKillTime > this.comboTimeout) {
            // Reset combo
            this.comboCount = 1;
            this.comboMultiplier = 1;
          } else {
            // Continue combo
            this.comboCount++;
            this.comboMultiplier = Math.min(1 + (this.comboCount - 1) * 0.2, 3); // Max 3x multiplier
          }

          this.lastKillTime = currentTime;

          // Update combo display
          this.updateComboDisplay();

          // Set combo timeout
          this.time.delayedCall(this.comboTimeout, () => {
            if (this.time.now - this.lastKillTime >= this.comboTimeout) {
              this.resetCombo();
            }
          });
        }

        updateComboDisplay() {
          if (this.comboCount > 1) {
            this.comboText.setText(
              `COMBO x${this.comboCount} (${this.comboMultiplier.toFixed(1)}x)`
            );
            this.comboText.setVisible(true);

            // Flash effect for combo
            this.tweens.add({
              targets: this.comboText,
              scaleX: 1.2,
              scaleY: 1.2,
              duration: 100,
              yoyo: true,
              ease: "Power2.easeOut",
            });
          } else {
            this.comboText.setVisible(false);
          }
        }

        resetCombo() {
          this.comboCount = 0;
          this.comboMultiplier = 1;
          this.comboText.setVisible(false);
        }

        showFloatingScore(x, y, score, isCrit = false) {
          // Create floating score text
          const scoreText = this.add.text(x, y, `+${score}`, {
            fontSize: "20px",
            fontFamily: "Fobble",
            color: isCrit ? "#ff00ff" : "#00ff00", // Purple for crit, green for normal
            stroke: "#000000",
            strokeThickness: 2,
            align: "center",
          });
          scoreText.setOrigin(0.5);
          scoreText.setDepth(200); // High depth to be visible above everything

          // Create crit text if it's a critical hit
          let critText = null;
          if (isCrit) {
            critText = this.add.text(x, y - 25, "CRIT!", {
              fontSize: "16px",
              fontFamily: "Fobble",
              color: "#ff00ff",
              stroke: "#000000",
              strokeThickness: 2,
              align: "center",
            });
            critText.setOrigin(0.5);
            critText.setDepth(201);
          }

          // Create combo text if combo is active
          let comboText = null;
          if (this.comboCount > 1) {
            comboText = this.add.text(x, y + 25, `COMBO x${this.comboCount}`, {
              fontSize: "14px",
              fontFamily: "Fobble",
              color: "#ff6b35",
              stroke: "#000000",
              strokeThickness: 2,
              align: "center",
            });
            comboText.setOrigin(0.5);
            comboText.setDepth(202);
          }

          // Animate floating upward and fading out
          this.tweens.add({
            targets: scoreText,
            y: y - 40,
            alpha: 0,
            duration: 1000,
            ease: "Power2.easeOut",
            onComplete: () => {
              scoreText.destroy();
            },
          });

          // Animate crit text if it exists
          if (critText) {
            this.tweens.add({
              targets: critText,
              y: y - 65,
              alpha: 0,
              duration: 1000,
              ease: "Power2.easeOut",
              onComplete: () => {
                critText.destroy();
              },
            });
          }

          // Animate combo text if it exists
          if (comboText) {
            this.tweens.add({
              targets: comboText,
              y: y - 15,
              alpha: 0,
              duration: 1000,
              ease: "Power2.easeOut",
              onComplete: () => {
                comboText.destroy();
              },
            });
          }
        }

        createHealthBar() {
          // Health bar background (rounded)
          this.healthBarBg = this.add.graphics();
          this.healthBarBg.fillStyle(0x333333, 0.8);
          this.healthBarBg.fillRoundedRect(-30, -50, 60, 8, 4);
          this.healthBarBg.setDepth(100);

          // Health bar fill (rounded)
          this.healthBar = this.add.graphics();
          this.healthBar.fillStyle(0x00ff00, 0.9);
          this.healthBar.fillRoundedRect(-30, -50, 60, 8, 4);
          this.healthBar.setDepth(101);

          // Position health bar above player
          this.updateHealthBarPosition();
        }

        updateHealthBarPosition() {
          if (!this.player || !this.healthBar || !this.healthBarBg) return;

          // Position health bar above player
          this.healthBarBg.x = this.player.x;
          this.healthBarBg.y = this.player.y - 2;
          this.healthBar.x = this.player.x;
          this.healthBar.y = this.player.y - 2;
        }

        updateHealthBar() {
          if (!this.healthBar || !this.player) return;

          const healthPercent = this.playerHealth / this.playerMaxHealth;
          const barWidth = 60 * healthPercent;

          // Clear and redraw health bar
          this.healthBar.clear();

          // Color based on health percentage
          let healthColor = 0x00ff00; // Green
          if (healthPercent < 0.3) {
            healthColor = 0xff0000; // Red
          } else if (healthPercent < 0.6) {
            healthColor = 0xffff00; // Yellow
          }

          this.healthBar.fillStyle(healthColor, 0.9);
          this.healthBar.fillRoundedRect(-30, -50, barWidth, 8, 4);

          // Update position
          this.updateHealthBarPosition();
        }

        updatePlayer(delta) {
          if (!this.player || !this.cursors) return;

          this.player.body.setVelocity(0);

          let velocityX = 0;
          let velocityY = 0;
          let isMoving = false;

          if (
            this.cursors.left.isDown ||
            this.wasd.A.isDown ||
            (this.mobileInput && this.mobileInput.left)
          ) {
            velocityX = -this.playerSpeed;
            this.player.setFlipX(true); // Face left
            isMoving = true;
          }
          if (
            this.cursors.right.isDown ||
            this.wasd.D.isDown ||
            (this.mobileInput && this.mobileInput.right)
          ) {
            velocityX = this.playerSpeed;
            this.player.setFlipX(false); // Face right
            isMoving = true;
          }
          if (
            this.cursors.up.isDown ||
            this.wasd.W.isDown ||
            (this.mobileInput && this.mobileInput.up)
          ) {
            velocityY = -this.playerSpeed;
            isMoving = true;
          }
          if (
            this.cursors.down.isDown ||
            this.wasd.S.isDown ||
            (this.mobileInput && this.mobileInput.down)
          ) {
            velocityY = this.playerSpeed;
            isMoving = true;
          }

          // Normalize diagonal movement
          if (velocityX !== 0 && velocityY !== 0) {
            velocityX *= 0.707;
            velocityY *= 0.707;
          }

          // Play appropriate animation
          if (isMoving) {
            // Switch to walk texture if not already using it
            if (this.player.texture.key !== "pudgyPenguin") {
              this.player.setTexture("pudgyPenguin");
            }
            this.player.anims.play("walk", true);
          } else {
            // Switch to idle texture if not already using it
            if (this.player.texture.key !== "pudgyPenguinIdle") {
              this.player.setTexture("pudgyPenguinIdle");
            }
            this.player.anims.play("idle", true);
          }

          // Apply Slip Stream - 50% faster when low health
          let speedMultiplier = 1;
          if (
            GameRegistry.upgrades.bellySlide &&
            this.playerHealth < this.playerMaxHealth * 0.3
          ) {
            speedMultiplier = 1.2; // 20% faster
          }

          // Apply movement with speed multiplier
          this.player.body.setVelocity(
            velocityX * speedMultiplier,
            velocityY * speedMultiplier
          );

          // Update health bar position
          this.updateHealthBarPosition();
        }

        updateEnemies(time, delta) {
          if (!this.player) return;

          for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];

            // Handle burning damage
            if (enemy.burning && enemy.burnDuration > 0) {
              enemy.burnDuration -= delta;
              if (time - enemy.lastBurnTick >= 1000) {
                // Damage every second
                enemy.health -= enemy.burnDamage;
                enemy.lastBurnTick = time;

                // Create burning damage particles
                this.createBurningDamageParticles(
                  enemy.sprite.x,
                  enemy.sprite.y
                );

                if (enemy.health <= 0) {
                  this.spawnEmberPickup(enemy.sprite.x, enemy.sprite.y);
                  enemy.sprite.destroy();
                  this.enemies.splice(i, 1);
                  continue;
                }
              }
            }

            // Different movement patterns based on enemy type
            switch (enemy.type) {
              case "small":
              case "big":
                // Standard movement towards player
                this.moveEnemyTowardsPlayer(enemy);
                break;

              case "swarm":
                // Swarm enemies move more erratically
                this.moveSwarmEnemy(enemy);
                break;

              case "boss":
                // Boss can charge at player
                this.updateBossEnemy(enemy, time);
                break;

              case "boss2":
                // Boss can charge at player
                this.updateBossEnemy(enemy, time);
                break;
            }
          }
        }

        updateSpriteDirection(sprite, velocityX, threshold = 5) {
          // Flip sprite based on horizontal movement direction
          // Only flip if velocity is significant enough to avoid rapid flipping
          if (velocityX > threshold) {
            sprite.setFlipX(true); // Moving right
          } else if (velocityX < -threshold) {
            sprite.setFlipX(false); // Moving left
          }
          // If velocityX is within threshold, keep current direction
        }

        applyEnemyHitback(enemy, bullet) {
          // Calculate direction from bullet to enemy for hitback (enemy gets pushed away from bullet)
          const angle = Phaser.Math.Angle.Between(
            bullet.sprite.x,
            bullet.sprite.y,
            enemy.sprite.x,
            enemy.sprite.y
          );

          // Hitback strength varies by enemy type and bullet damage
          let hitbackStrength = 100; // Base hitback strength

          console.log(
            "Hitback called for enemy type:",
            enemy.type,
            "angle:",
            angle
          );

          // Adjust hitback based on enemy type
          switch (enemy.type) {
            case "small":
              hitbackStrength = 300; // Small enemies get pushed more
              break;
            case "big":
              hitbackStrength = 120; // Big enemies resist more
              break;
            case "swarm":
              hitbackStrength = 350; // Swarm enemies are light
              break;
            case "boss":
              hitbackStrength = 70; // Boss resists hitback
              break;
            case "boss2":
              hitbackStrength = 50; // Boss resists hitback
              break;
          }

          // Scale hitback by bullet damage
          const damage = bullet.damage || 10;
          hitbackStrength *= damage / 25; // Scale based on damage

          // Calculate hitback velocity
          const hitbackX = Math.cos(angle) * hitbackStrength;
          const hitbackY = Math.sin(angle) * hitbackStrength;

          console.log(
            "Hitback values - strength:",
            hitbackStrength,
            "X:",
            hitbackX,
            "Y:",
            hitbackY
          );
          console.log(
            "Enemy current velocity before:",
            enemy.sprite.body.velocity.x,
            enemy.sprite.body.velocity.y
          );

          // Store hitback as a property on the enemy that will be applied in movement
          enemy.hitbackX = hitbackX;
          enemy.hitbackY = hitbackY;
          enemy.hitbackTime = this.time.now;
          enemy.hitbackDuration = 300; // Hitback lasts 300ms

          console.log(
            "Stored hitback - X:",
            hitbackX,
            "Y:",
            hitbackY,
            "Duration: 300ms"
          );

          // Add a brief visual effect - slight scale down and back up
          const originalScale = enemy.sprite.scaleX;
          this.tweens.add({
            targets: enemy.sprite,
            scaleX: originalScale * 0.9,
            scaleY: originalScale * 0.9,
            duration: 100,
            yoyo: true,
            ease: "Power2.easeOut",
            onComplete: () => {
              enemy.sprite.setScale(originalScale);
            },
          });
        }

        moveEnemyTowardsPlayer(enemy) {
          const angle = Phaser.Math.Angle.Between(
            enemy.sprite.x,
            enemy.sprite.y,
            this.player.x,
            this.player.y
          );

          // Apply frost effect if active
          let speedMultiplier = 1;
          if (
            enemy.frost &&
            this.time.now - enemy.lastFrostTime < enemy.frostDuration
          ) {
            speedMultiplier = enemy.frostSpeedMultiplier;
            console.log("Enemy slowed by frost:", speedMultiplier);
          } else if (enemy.frost) {
            // Frost effect expired
            enemy.frost = false;
            console.log("Frost effect expired");
          }

          const velocityX = Math.cos(angle) * enemy.speed * speedMultiplier;
          const velocityY = Math.sin(angle) * enemy.speed * speedMultiplier;

          // Apply hitback if active
          let finalVelocityX = velocityX;
          let finalVelocityY = velocityY;

          if (enemy.hitbackX !== undefined && enemy.hitbackY !== undefined) {
            const hitbackAge = this.time.now - enemy.hitbackTime;
            if (hitbackAge < enemy.hitbackDuration) {
              // Apply hitback with decay over time
              const hitbackDecay = 1 - hitbackAge / enemy.hitbackDuration;
              finalVelocityX += enemy.hitbackX * hitbackDecay;
              finalVelocityY += enemy.hitbackY * hitbackDecay;

              console.log(
                "Applying hitback - decay:",
                hitbackDecay,
                "final X:",
                finalVelocityX,
                "final Y:",
                finalVelocityY
              );
            } else {
              // Hitback expired, clear it
              enemy.hitbackX = undefined;
              enemy.hitbackY = undefined;
            }
          }

          enemy.sprite.body.setVelocity(finalVelocityX, finalVelocityY);

          // Update sprite direction based on base movement only (ignore hitback)
          if (
            !(
              enemy.hitbackX !== undefined &&
              enemy.hitbackY !== undefined &&
              this.time.now - enemy.hitbackTime < enemy.hitbackDuration
            )
          ) {
            this.updateSpriteDirection(enemy.sprite, velocityX);
          }
        }

        moveSwarmEnemy(enemy) {
          // Swarm enemies move more erratically with slight randomness
          const angle = Phaser.Math.Angle.Between(
            enemy.sprite.x,
            enemy.sprite.y,
            this.player.x,
            this.player.y
          );

          // Add some randomness to make them more chaotic
          const randomOffset = Phaser.Math.Between(-0.1, 0.1); // Reduced from -0.3 to 0.3
          const finalAngle = angle + randomOffset;

          // Apply frost effect if active
          let speedMultiplier = 1;
          if (
            enemy.frost &&
            this.time.now - enemy.lastFrostTime < enemy.frostDuration
          ) {
            speedMultiplier = enemy.frostSpeedMultiplier;
          } else if (enemy.frost) {
            // Frost effect expired
            enemy.frost = false;
          }

          const velocityX =
            Math.cos(finalAngle) * enemy.speed * speedMultiplier;
          const velocityY =
            Math.sin(finalAngle) * enemy.speed * speedMultiplier;

          // Apply hitback if active
          let finalVelocityX = velocityX;
          let finalVelocityY = velocityY;

          if (enemy.hitbackX !== undefined && enemy.hitbackY !== undefined) {
            const hitbackAge = this.time.now - enemy.hitbackTime;
            if (hitbackAge < enemy.hitbackDuration) {
              // Apply hitback with decay over time
              const hitbackDecay = 1 - hitbackAge / enemy.hitbackDuration;
              finalVelocityX += enemy.hitbackX * hitbackDecay;
              finalVelocityY += enemy.hitbackY * hitbackDecay;
            } else {
              // Hitback expired, clear it
              enemy.hitbackX = undefined;
              enemy.hitbackY = undefined;
            }
          }

          enemy.sprite.body.setVelocity(finalVelocityX, finalVelocityY);

          // Update sprite direction based on base movement only (ignore hitback)
          if (
            !(
              enemy.hitbackX !== undefined &&
              enemy.hitbackY !== undefined &&
              this.time.now - enemy.hitbackTime < enemy.hitbackDuration
            )
          ) {
            this.updateSpriteDirection(enemy.sprite, velocityX);
          }
        }

        updateBossEnemy(enemy, time) {
          const distanceToPlayer = Phaser.Math.Distance.Between(
            enemy.sprite.x,
            enemy.sprite.y,
            this.player.x,
            this.player.y
          );

          // Boss charges when close enough and cooldown is ready
          if (
            distanceToPlayer < 100 &&
            time - enemy.lastCharge > enemy.chargeCooldown
          ) {
            this.bossCharge(enemy);
            enemy.lastCharge = time;
          } else {
            // Normal movement towards player
            this.moveEnemyTowardsPlayer(enemy);
          }
        }

        bossCharge(enemy) {
          // Boss charges directly at player with increased speed
          const angle = Phaser.Math.Angle.Between(
            enemy.sprite.x,
            enemy.sprite.y,
            this.player.x,
            this.player.y
          );

          // Apply frost effect if active
          let speedMultiplier = 3; // Base charge speed
          if (
            enemy.frost &&
            this.time.now - enemy.lastFrostTime < enemy.frostDuration
          ) {
            speedMultiplier *= enemy.frostSpeedMultiplier; // Apply frost to charge
          } else if (enemy.frost) {
            // Frost effect expired
            enemy.frost = false;
          }

          // Charge with speed affected by frost
          const velocityX = Math.cos(angle) * enemy.speed * speedMultiplier;
          const velocityY = Math.sin(angle) * enemy.speed * speedMultiplier;

          enemy.sprite.body.setVelocity(velocityX, velocityY);

          // Update sprite direction based on movement
          this.updateSpriteDirection(enemy.sprite, velocityX);
        }

        updateBullets() {
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];

            // Remove bullets that are out of bounds
            if (
              bullet.sprite.x < 0 ||
              bullet.sprite.x > 400 ||
              bullet.sprite.y < 0 ||
              bullet.sprite.y > 600
            ) {
              bullet.sprite.destroy();
              this.bullets.splice(i, 1);
              continue;
            }

            // Remove bullets that exceeded their max travel distance
            if (
              bullet.startX !== undefined &&
              bullet.startY !== undefined &&
              bullet.maxDistance !== undefined
            ) {
              const traveled = Phaser.Math.Distance.Between(
                bullet.startX,
                bullet.startY,
                bullet.sprite.x,
                bullet.sprite.y
              );
              if (traveled >= bullet.maxDistance) {
                bullet.sprite.destroy();
                this.bullets.splice(i, 1);
                continue;
              }
            }
          }
        }

        checkCollisions() {
          if (!this.player) return;

          // Check bullet vs enemy collisions
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            const bullet = this.bullets[i];
            if (!bullet.isPlayerBullet) continue;

            for (let j = this.enemies.length - 1; j >= 0; j--) {
              const enemy = this.enemies[j];

              const distance = Phaser.Math.Distance.Between(
                bullet.sprite.x,
                bullet.sprite.y,
                enemy.sprite.x,
                enemy.sprite.y
              );

              // Different hit distances based on enemy type and sprite size
              let hitDistance = 14; // Default
              switch (enemy.type) {
                case "small":
                  hitDistance = 20; // enemy1 sprite
                  break;
                case "big":
                  hitDistance = 30; // enemy3 sprite
                  break;
                case "swarm":
                  hitDistance = 15; // enemy2 sprite (flying)
                  break;
                case "boss":
                  hitDistance = 35; // enemy4 sprite
                  break;
              }

              if (distance < hitDistance) {
                // Hit!
                const damage = bullet.damage || 10;
                enemy.health -= damage;
                this.sound.play("HitFx", {
                  volume: 0.5,
                  detune: Phaser.Math.Between(-50, 50),
                });
                // Create hit particles
                this.createHitParticles(
                  enemy.sprite.x,
                  enemy.sprite.y,
                  bullet.isCrit
                );

                // Apply burning effect
                if (bullet.burning) {
                  enemy.burning = true;
                  enemy.burnDuration = 3000; // 3 seconds
                  enemy.burnDamage = 2;
                  enemy.lastBurnTick = this.time.now;

                  // Create burning hit particles
                  this.createBurningHitParticles(
                    enemy.sprite.x,
                    enemy.sprite.y
                  );
                }

                // Apply frost effect
                if (bullet.frost) {
                  console.log("Applying frost effect to enemy");
                  enemy.frost = true;
                  enemy.frostDuration = 5000; // 5 seconds
                  enemy.frostSpeedMultiplier = 0.5; // Slow down by 50%
                  enemy.lastFrostTime = this.time.now;
                  console.log(
                    "Frost effect applied:",
                    enemy.frost,
                    enemy.frostSpeedMultiplier
                  );
                }

                // Apply hitback effect
                this.applyEnemyHitback(enemy, bullet);

                // Destroy bullet on hit
                bullet.sprite.destroy();
                this.bullets.splice(i, 1);

                if (enemy.health <= 0) {
                  const deathSound = Phaser.Utils.Array.GetRandom([
                    "DeathFx1",
                    "DeathFx2",
                    "DeathFx3",
                    "DeathFx5",
                  ]);

                  this.sound.play(deathSound, {
                    volume: 0.5,
                    detune: Phaser.Math.Between(-50, 50),
                  });
                  this.sound.play("EnemyExplosionFx", {
                    volume: 0.4,
                    detune: Phaser.Math.Between(-50, 50),
                  });
                  this.sound.play("HitFx", {
                    volume: 0.5,
                    detune: Phaser.Math.Between(-50, 50),
                  });
                  this.sound.play("DropEmberFx", { volume: 0.4 });
                  // Spawn ember pickup at enemy position
                  this.spawnEmberPickup(enemy.sprite.x, enemy.sprite.y);
                  // Explosion effect
                  this.playEnemyExplosion(enemy.sprite.x, enemy.sprite.y);

                  // Update combo system
                  this.updateCombo();

                  // Add score for kill with multiplier and combo
                  const baseScore = 10;
                  const finalScore = Math.floor(
                    baseScore * this.scoreMultiplier * this.comboMultiplier
                  );
                  this.score += finalScore;
                  this.scoreText.setText(`Score: ${this.score}`);

                  // Show floating score text
                  this.showFloatingScore(
                    enemy.sprite.x,
                    enemy.sprite.y,
                    finalScore,
                    bullet.isCrit
                  );

                  enemy.sprite.destroy();
                  this.enemies.splice(j, 1);
                }
                break;
              }
            }
          }

          // Check enemy collision with player
          for (const enemy of this.enemies) {
            const distance = Phaser.Math.Distance.Between(
              enemy.sprite.x,
              enemy.sprite.y,
              this.player.x,
              this.player.y
            );

            if (distance < 22) {
              let damage = 0.3;

              // Apply cold resistance
              if (GameRegistry.upgrades.coldResistance) {
                damage *= 0.9; // 10% damage reduction
              }

              // Apply ice armor damage reduction
              if (GameRegistry.upgrades.iceArmor) {
                damage *= 0.8; // 20% damage reduction
              }

              this.playerHealth -= damage;

              // Visual and haptic feedback for taking damage
              // Red tint flash
              this.player.setTint(0xff0000);
              this.time.delayedCall(200, () => {
                this.player.clearTint();
              });

              // Screen shake
              this.cameras.main.shake(100, 0.005);

              // Haptic feedback
              if (
                sdk &&
                sdk.singlePlayer &&
                sdk.singlePlayer.actions.hapticFeedback
              ) {
                sdk.singlePlayer.actions.hapticFeedback();
              }

              this.updateHealthBar();

              // Fire Nova - 5% chance to emit damaging nova when hit
              if (GameRegistry.upgrades.fireTotem && Math.random() < 0.025) {
                this.emitFireNova(this.player.x, this.player.y);
              }

              if (this.playerHealth <= 0) {
                const DeathSound = Phaser.Utils.Array.GetRandom([
                  "DeathFx1",
                  "DeathFx2",
                  "DeathFx3",
                  "DeathFx4",
                  "DeathFx5",
                ]);
                this.sound.play(DeathSound, {
                  volume: 0.5,
                  detune: Phaser.Math.Between(-50, 50),
                });
                // Check for phoenix rebirth
                if (
                  GameRegistry.upgrades.phoenixRebirth &&
                  Math.random() < 0.25
                ) {
                  this.playerHealth = this.playerMaxHealth * 0.5; // Revive with 50% health
                  this.sound.play("FireSpellFx", {
                    volume: 0.5,
                    detune: Phaser.Math.Between(-50, 50),
                  });
                  this.updateHealthBar();
                  this.player.setTint(0xff4500);
                  this.time.delayedCall(1000, () => {
                    this.player.clearTint();
                  });
                } else {
                  this.gameOver();
                }
              }
            }
          }
        }

        gameOver() {
          // Save stats to registry (embers already added during collection)
          const survivalTime = Math.floor(this.gameTime / 1000);
          if (survivalTime > GameRegistry.bestWave) {
            GameRegistry.bestWave = survivalTime;
          }

          // Save to Farcade SDK
          gameData.saveGameState();

          // Use the accumulated score (already includes kills and wave bonuses)
          const finalScore = this.score;

          // Pause game physics
          this.physics.pause();

          // Stop update loop to prevent further execution
          // this.scene.pause();

          // Dark overlay
          const overlay = this.add.rectangle(200, 300, 400, 600, 0x000000, 0.9);
          overlay.setScrollFactor(0);
          overlay.setDepth(1000);

          // Display game over panel (rounded + cartoony)
          const panelX = 200 - 180;
          const panelY = 300 - 200;
          const panelW = 360;
          const panelH = 400;

          const gameOverText = this.add
            .text(200, 150, "YOU DIED", {
              fontSize: "66px",
              fontFamily: "Fobble",
              color: "#ff0000",
              stroke: "#000000",
              strokeThickness: 6,
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1002);

          const statsHeading = this.add
            .text(200, 220, "=== RUN STATS ===", {
              fontSize: "40px",
              fontFamily: "Fobble",
              color: "#ffff00",
              stroke: "#000000",
              strokeThickness: 3,
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1002);

          const statsText = this.add
            .text(
              200,
              290,
              `Survival Time: ${Math.floor(
                this.gameTime / 1000
              )}s\nEmbers This Run: ${this.emberCount}`,
              {
                fontSize: "32px",
                fontFamily: "Fobble",
                color: "#ffffff",
                stroke: "#000000",
                strokeThickness: 3,
                align: "center",
                lineSpacing: 8,
              }
            )
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1002);

          const finalScoreText = this.add
            .text(200, 390, `FINAL SCORE: ${finalScore}`, {
              fontSize: "36px",
              fontFamily: "Fobble",
              color: "#00ff00",
              stroke: "#000000",
              strokeThickness: 4,
              align: "center",
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1002);

          const embersSavedText = this.add
            .text(200, 495, `(Embers saved)`, {
              fontSize: "22px",
              fontFamily: "Fobble",
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 3,
              align: "center",
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1002);

          // End game button (rounded)
          const btnW = 280;
          const btnH = 54;
          const btnX = 200 - btnW / 2;
          const btnY = 450 - btnH / 2;

          const drawButton = (g, fillColor) => {
            g.clear();
            // Match shop close button style
            g.fillStyle(fillColor, 0.9);
            g.lineStyle(3, 0xe53e3e, 1);
            g.fillRoundedRect(btnX, btnY, btnW, btnH, 20);
            g.strokeRoundedRect(btnX, btnY, btnW, btnH, 20);
          };

          const endGameBtnG = this.add.graphics();
          endGameBtnG.setScrollFactor(0);
          endGameBtnG.setDepth(1002);
          drawButton(endGameBtnG, 0xf56565);

          // Interactive zone over button
          const endGameBtnZone = this.add
            .zone(200, 450, btnW, btnH)
            .setRectangleDropZone(btnW, btnH);
          endGameBtnZone.setInteractive({
            useHandCursor: true,
            draggable: false,
          });
          endGameBtnZone.setScrollFactor(0);
          endGameBtnZone.setDepth(1003);

          const endGameText = this.add
            .text(200, 450, "END GAME", {
              fontSize: "38px",
              fontFamily: "Fobble",
              color: "#ffffff",
              stroke: "#000000",
              strokeThickness: 4,
              align: "center",
            })
            .setOrigin(0.5)
            .setScrollFactor(0)
            .setDepth(1003);

          // Button hover effects
          endGameBtnZone.on("pointerover", () => {
            drawButton(endGameBtnG, 0xff6b6b);
          });

          endGameBtnZone.on("pointerout", () => {
            drawButton(endGameBtnG, 0xf56565);
          });

          // End game action
          endGameBtnZone.on("pointerdown", () => {
            console.log("End game button clicked, SDK available:", !!sdk);
            console.log("Final score:", finalScore);

            // Send game over to Farcade SDK
            if (sdk && sdk.singlePlayer && sdk.singlePlayer.actions) {
              try {
                sdk.singlePlayer.actions.gameOver({ score: finalScore });
                console.log("Game over sent to SDK successfully");
                // SDK will handle navigation back to platform
              } catch (error) {
                console.error("Error calling SDK gameOver:", error);
                // Fallback to igloo hub
                this.sound.stopAll();
                this.scene.stop();
                this.scene.start("IglooHubScene");
              }
            } else {
              console.log("SDK not available, returning to igloo hub");
              // Standalone mode: return to igloo hub
              this.sound.stopAll();
              this.scene.stop();
              this.scene.start("IglooHubScene");
            }
          });
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: 400,
        height: 600,
        parent: "game-container",
        backgroundColor: "#0a0a0a",
        physics: {
          default: "arcade",
          arcade: {
            gravity: { x: 0, y: 0 },
            debug: false,
          },
        },
        scene: [BootLoader, IglooHubScene, GameScene],
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
        },
      };

      // Farcade SDK Integration
      // Start the game
      const game = new Phaser.Game(config);

      // Initialize game data when SDK is ready
      if (sdk && sdk.singlePlayer) {
        sdk.singlePlayer.actions
          .ready()
          .then((gameInfo) => {
            if (gameInfo && gameInfo.initialGameState) {
              gameData.initialize(gameInfo.initialGameState.gameState);
            } else {
              gameData.initialize();
            }
          })
          .catch((error) => {
            console.log(
              "Farcade SDK not available, running in standalone mode",
              error
            );
            gameData.initialize();
          });

        // Farcade SDK event handlers
        sdk.on("play_again", () => {
          // Reset to igloo hub
          const currentScene = game.scene.getScenes(true)[0];
          if (currentScene) {
            // Reset all in-game upgrades if we're in GameScene
            if (currentScene.scene.key === "GameScene") {
              // Reset player stats to base values
              currentScene.playerHealth = 100;
              currentScene.playerMaxHealth = 100;
              currentScene.playerSpeed = 100;
              currentScene.playerDamage = 25;
              currentScene.playerFireRate = 500;

              // Reset upgrade properties
              currentScene.critChance = 0;
              currentScene.multiShot = false;
              currentScene.scoreMultiplier = 1;
              currentScene.fowRadiusMultiplier = 1;
              currentScene.emberMagnet = false;

              // Reset XP system
              currentScene.currentXP = 0;
              currentScene.currentLevel = 1;
              currentScene.xpToNextLevel = 100;

              // Reset combo system
              currentScene.comboCount = 0;
              currentScene.comboMultiplier = 1;
              currentScene.lastComboTime = 0;

              // Reset game state
              // currentScene.emberCount = 0;
              currentScene.score = 0;
              currentScene.gameTime = 0;
            }

            currentScene.sound.stopAll();
            currentScene.scene.start("IglooHubScene");
          }
        });

        sdk.on("toggle_mute", ({ isMuted }) => {
          gameData.isMuted = isMuted;
          if (game && game.sound) {
            game.sound.mute = isMuted;
          }
        });
      } else {
        // No SDK available, initialize with defaults
        console.warn("Farcade SDK not found - running in standalone mode");
        gameData.initialize();
      }
    </script>
  </body>
</html>
